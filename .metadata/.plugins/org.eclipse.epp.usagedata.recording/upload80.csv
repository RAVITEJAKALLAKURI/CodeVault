what,kind,bundleId,bundleVersion,description,time
started,bundle,org.eclipse.equinox.p2.core,2.1.0.v20110502-1955,"org.eclipse.equinox.p2.core",1419752900513
started,bundle,org.eclipse.equinox.p2.directorywatcher,1.0.300.v20110502-1955,"org.eclipse.equinox.p2.directorywatcher",1419752900513
started,bundle,org.eclipse.equinox.p2.engine,2.1.0.v20110511,"org.eclipse.equinox.p2.engine",1419752900514
started,bundle,org.eclipse.equinox.p2.metadata,2.1.0.v20110510,"org.eclipse.equinox.p2.metadata",1419752900515
started,bundle,org.eclipse.equinox.p2.metadata.repository,1.2.0.v20110511-1359,"org.eclipse.equinox.p2.metadata.repository",1419752900515
started,bundle,org.eclipse.equinox.p2.operations,2.1.0.v20110511-1821,"org.eclipse.equinox.p2.operations",1419752900516
started,bundle,org.eclipse.equinox.p2.reconciler.dropins,1.1.100.v20110510,"org.eclipse.equinox.p2.reconciler.dropins",1419752900516
started,bundle,org.eclipse.equinox.p2.repository,2.1.0.v20110601,"org.eclipse.equinox.p2.repository",1419752900517
started,bundle,org.eclipse.equinox.p2.ui.sdk.scheduler,1.0.100.v20110502-1955,"org.eclipse.equinox.p2.ui.sdk.scheduler",1419752900519
started,bundle,org.eclipse.equinox.p2.updatechecker,1.1.200.v20110502-1955,"org.eclipse.equinox.p2.updatechecker",1419752900519
started,bundle,org.eclipse.equinox.preferences,3.4.1.R37x_v20110725,"org.eclipse.equinox.preferences",1419752900520
started,bundle,org.eclipse.equinox.registry,3.5.101.R37x_v20110810-1611,"org.eclipse.equinox.registry",1419752900520
started,bundle,org.eclipse.equinox.security,1.1.1.R37x_v20110822-1018,"org.eclipse.equinox.security",1419752900630
started,bundle,org.eclipse.equinox.util,1.0.300.v20110502,"org.eclipse.equinox.util",1419752900631
started,bundle,org.eclipse.help,3.5.100.v20110426,"org.eclipse.help",1419752900641
started,bundle,org.eclipse.jdt.apt.core,3.3.500.v20110420-1015,"org.eclipse.jdt.apt.core",1419752900643
started,bundle,org.eclipse.jdt.apt.pluggable.core,1.0.400.v20110305-1450,"org.eclipse.jdt.apt.pluggable.core",1419752900644
started,bundle,org.eclipse.jdt.core,3.7.1.v_B76_R37x,"org.eclipse.jdt.core",1419752900645
started,bundle,org.eclipse.jdt.core.manipulation,1.4.0.v20110505-0800,"org.eclipse.jdt.core.manipulation",1419752900646
started,bundle,org.eclipse.jdt.launching,3.6.1.v20110803_r371,"org.eclipse.jdt.launching",1419752900647
started,bundle,org.eclipse.jdt.ui,3.7.1.r371_v20110824-0800,"org.eclipse.jdt.ui",1419752900647
started,bundle,org.eclipse.jface,3.7.0.I20110522-1430,"org.eclipse.jface",1419752900647
started,bundle,org.eclipse.ltk.core.refactoring,3.5.201.r371_v20110824-0800,"org.eclipse.ltk.core.refactoring",1419752900648
started,bundle,org.eclipse.ltk.ui.refactoring,3.6.0.v20110505-0800,"org.eclipse.ltk.ui.refactoring",1419752900654
started,bundle,org.eclipse.mylyn.bugzilla.core,3.6.2.v20110903-0100,"org.eclipse.mylyn.bugzilla.core",1419752900655
started,bundle,org.eclipse.mylyn.bugzilla.ui,3.6.0.v20110608-1400,"org.eclipse.mylyn.bugzilla.ui",1419752900656
started,bundle,org.eclipse.mylyn.commons.identity,0.8.0.v20110608-1400,"org.eclipse.mylyn.commons.identity",1419752900656
started,bundle,org.eclipse.mylyn.commons.net,3.6.0.v20110608-1400,"org.eclipse.mylyn.commons.net",1419752900656
started,bundle,org.eclipse.mylyn.commons.ui,3.6.1.v20110720-0100,"org.eclipse.mylyn.commons.ui",1419752900657
started,bundle,org.eclipse.mylyn.context.core,3.6.1.v20110720-0100,"org.eclipse.mylyn.context.core",1419752900657
started,bundle,org.eclipse.mylyn.context.ui,3.6.0.v20110608-1400,"org.eclipse.mylyn.context.ui",1419752900658
started,bundle,org.eclipse.mylyn.monitor.ui,3.6.0.v20110608-1400,"org.eclipse.mylyn.monitor.ui",1419752900658
started,bundle,org.eclipse.mylyn.tasks.ui,3.6.2.v20110826-0100,"org.eclipse.mylyn.tasks.ui",1419752900673
started,bundle,org.eclipse.search,3.7.0.v20110505-0800,"org.eclipse.search",1419752900700
started,bundle,org.eclipse.team.core,3.6.0.I20110525-0800,"org.eclipse.team.core",1419752900701
started,bundle,org.eclipse.ui,3.7.0.I20110602-0100,"org.eclipse.ui",1419752900702
started,bundle,org.eclipse.ui.editors,3.7.0.v20110517-0800,"org.eclipse.ui.editors",1419752900702
started,bundle,org.eclipse.ui.forms,3.5.100.v20110425,"org.eclipse.ui.forms",1419752900703
started,bundle,org.eclipse.ui.ide,3.7.0.v20110809-1737,"org.eclipse.ui.ide",1419752900705
started,bundle,org.eclipse.ui.net,1.2.100.I20110511-0800,"org.eclipse.ui.net",1419752900705
started,bundle,org.eclipse.ui.views,3.6.0.I20110412-0800,"org.eclipse.ui.views",1419752900706
started,bundle,org.eclipse.ui.workbench,3.7.0.I20110519-0100,"org.eclipse.ui.workbench",1419752900727
started,bundle,org.eclipse.ui.workbench.texteditor,3.7.0.v20110505-0800,"org.eclipse.ui.workbench.texteditor",1419752900736
started,bundle,org.eclipse.wst.common.project.facet.core,1.4.200.v201103170332,"org.eclipse.wst.common.project.facet.core",1419752900737
started,bundle,org.eclipse.wst.web,1.1.500.v201104251400,"org.eclipse.wst.web",1419752900738
os,sysinfo,,,"win32",1419752900741
arch,sysinfo,,,"x86",1419752900741
ws,sysinfo,,,"win32",1419752900741
locale,sysinfo,,,"en_IN",1419752900741
processors,sysinfo,,,"4",1419752900741
java.runtime.name,sysinfo,,,"Java(TM) SE Runtime Environment",1419752900741
java.runtime.version,sysinfo,,,"1.6.0_29-b11",1419752900741
java.specification.name,sysinfo,,,"Java Platform API Specification",1419752900741
java.specification.vendor,sysinfo,,,"Sun Microsystems Inc.",1419752900741
java.specification.version,sysinfo,,,"1.6",1419752900741
java.vendor,sysinfo,,,"Sun Microsystems Inc.",1419752900741
java.version,sysinfo,,,"1.6.0_29",1419752900741
java.vm.info,sysinfo,,,"mixed mode, sharing",1419752900741
java.vm.name,sysinfo,,,"Java HotSpot(TM) Client VM",1419752900741
java.vm.specification.name,sysinfo,,,"Java Virtual Machine Specification",1419752900741
java.vm.specification.vendor,sysinfo,,,"Sun Microsystems Inc.",1419752900741
java.vm.specification.version,sysinfo,,,"1.0",1419752900741
java.vm.vendor,sysinfo,,,"Sun Microsystems Inc.",1419752900741
java.vm.version,sysinfo,,,"20.4-b02",1419752900741
started,bundle,org.eclipse.update.scheduler,3.2.300.v20100512,"org.eclipse.update.scheduler",1419752900836
started,bundle,org.eclipse.emf.common,2.7.0.v20110912-0920,"org.eclipse.emf.common",1419752900932
started,bundle,org.eclipse.emf.ecore,2.7.0.v20110912-0920,"org.eclipse.emf.ecore",1419752901457
started,bundle,org.eclipse.jsch.core,1.1.300.I20110514-0800,"org.eclipse.jsch.core",1419752901690
started,bundle,org.eclipse.team.cvs.core,3.3.400.I20110510-0800,"org.eclipse.team.cvs.core",1419752901693
started,bundle,org.eclipse.emf.ecore.xmi,2.7.0.v20110520-1406,"org.eclipse.emf.ecore.xmi",1419752901958
started,bundle,org.eclipse.update.configurator,3.3.100.v20100512,"org.eclipse.update.configurator",1419752902219
started,bundle,org.eclipse.team.ui,3.6.100.I20110525-0800,"org.eclipse.team.ui",1419752902246
started,bundle,org.eclipse.update.core,3.2.500.v20110330,"org.eclipse.update.core",1419752902256
started,bundle,org.eclipse.ui.console,3.5.100.v20110511,"org.eclipse.ui.console",1419752902463
started,bundle,org.sf.feeling.decompiler,1.0.3.201211040213,"org.sf.feeling.decompiler",1419752902506
started,bundle,org.eclipse.team.cvs.ui,3.3.400.I20110510-0800,"org.eclipse.team.cvs.ui",1419752902668
started,bundle,org.eclipse.jst.common.project.facet.core,1.4.200.v201103170302,"org.eclipse.jst.common.project.facet.core",1419752902819
started,bundle,org.eclipse.jst.ws.jaxrs.core,1.0.301.v201108240656,"org.eclipse.jst.ws.jaxrs.core",1419752902844
started,bundle,org.eclipse.pde.launching,3.6.0.v20110506,"org.eclipse.pde.launching",1419752903473
started,bundle,org.eclipse.ui.views.log,1.0.200.v20110404,"org.eclipse.ui.views.log",1419752903490
started,bundle,org.eclipse.pde.ui,3.6.100.v20110603,"org.eclipse.pde.ui",1419752903514
opened,view,org.eclipse.jdt.ui,3.7.1.r371_v20110824-0800,"org.eclipse.jdt.ui.PackageExplorer",1419752903923
activated,view,org.eclipse.jdt.ui,3.7.1.r371_v20110824-0800,"org.eclipse.jdt.ui.PackageExplorer",1419752903981
activated,editor,org.eclipse.jdt.ui,3.7.1.r371_v20110824-0800,"org.eclipse.jdt.ui.CompilationUnitEditor",1419752904072
opened,view,org.eclipse.ui.ide,3.7.0.v20110809-1737,"org.eclipse.ui.views.ProblemView",1419752904509
activated,view,org.eclipse.jdt.ui,3.7.1.r371_v20110824-0800,"org.eclipse.jdt.ui.PackageExplorer",1419752905035
started,bundle,org.eclipse.compare,3.5.201.R37x_v20110817-0800,"org.eclipse.compare",1419752918593
deactivated,workbench,org.eclipse.ui.workbench,3.7.0.I20110519-0100,"",1419752932820
activated,workbench,org.eclipse.ui.workbench,3.7.0.I20110519-0100,"",1419752947495
started,bundle,org.eclipse.wst.common.frameworks,1.2.101.v201107192200,"org.eclipse.wst.common.frameworks",1419752947689
started,bundle,org.eclipse.wst.common.emf,1.2.100.v201101101900,"org.eclipse.wst.common.emf",1419752947752
started,bundle,org.eclipse.jem.util,2.1.100.v201103021400,"org.eclipse.jem.util",1419752947783
started,bundle,org.eclipse.wst.common.emfworkbench.integration,1.2.101.v201107140600,"org.eclipse.wst.common.emfworkbench.integration",1419752947787
started,bundle,org.eclipse.wst.common.core,1.2.0.v200908252030,"org.eclipse.wst.common.core",1419752947849
started,bundle,org.eclipse.wst.common.modulecore,1.2.101.v201108231700,"org.eclipse.wst.common.modulecore",1419752947854
opened,editor,org.eclipse.jdt.ui,3.7.1.r371_v20110824-0800,"org.eclipse.jdt.ui.CompilationUnitEditor",1419752947896
started,bundle,org.eclipse.jst.j2ee.core,1.2.101.v201108110300,"org.eclipse.jst.j2ee.core",1419752947958
activated,editor,org.eclipse.jdt.ui,3.7.1.r371_v20110824-0800,"org.eclipse.jdt.ui.CompilationUnitEditor",1419752947976
started,bundle,org.eclipse.jem,2.0.500.v201104271400,"org.eclipse.jem",1419752947991
started,bundle,org.eclipse.wst.common.frameworks.ui,1.2.100.v201105122000,"org.eclipse.wst.common.frameworks.ui",1419752948055
started,bundle,org.eclipse.wst.xml.core,1.1.601.v201108302147,"org.eclipse.wst.xml.core",1419752948106
started,bundle,org.eclipse.wst.validation,1.2.302.v201107140600,"org.eclipse.wst.validation",1419752948166
started,bundle,org.eclipse.jst.j2ee,1.1.501.v201108231845,"org.eclipse.jst.j2ee",1419752948558
executed,command,org.eclipse.ui,3.7.0.I20110602-0100,"org.eclipse.ui.edit.selectAll",1419752949414
executed,command,org.eclipse.ui,3.7.0.I20110602-0100,"org.eclipse.ui.edit.paste",1419752950362
started,bundle,org.eclipse.jdt.junit,3.7.0.v20110505-0800,"org.eclipse.jdt.junit",1419752951184
executed,command,org.eclipse.ui,3.7.0.I20110602-0100,"org.eclipse.ui.file.save",1419752951658
started,bundle,org.eclipse.mylyn.ide.ui,3.6.0.v20110608-1400,"org.eclipse.mylyn.ide.ui",1419752955224
started,bundle,org.eclipse.jpt.jaxb.ui,1.1.1.v201108080010,"org.eclipse.jpt.jaxb.ui",1419752955309
started,bundle,org.eclipse.jpt.jpa.ui,3.0.1.v201108080010,"org.eclipse.jpt.jpa.ui",1419752955376
started,bundle,org.eclipse.jpt.common.core,1.0.1.v201108080010,"org.eclipse.jpt.common.core",1419752955446
started,bundle,org.eclipse.jpt.jpa.core,3.0.1.v201109073010,"org.eclipse.jpt.jpa.core",1419752955474
started,bundle,org.eclipse.jst.ws.jaxws.ui,1.0.100.v201104032053,"org.eclipse.jst.ws.jaxws.ui",1419752955555
started,bundle,org.eclipse.mylyn.java.ui,3.6.0.v20110608-1400,"org.eclipse.mylyn.java.ui",1419752955581
started,bundle,org.eclipse.pde.api.tools,1.0.301.v20110728_r371,"org.eclipse.pde.api.tools",1419752955756
started,bundle,org.eclipse.pde.api.tools.ui,1.0.301.v20110803_r371,"org.eclipse.pde.api.tools.ui",1419752955762
started,bundle,org.eclipse.jpt.jaxb.core,1.0.1.v201108080010,"org.eclipse.jpt.jaxb.core",1419752956121
executed,command,org.eclipse.ui,3.7.0.I20110602-0100,"org.eclipse.ui.edit.text.contentAssist.proposals",1419752956336
executed,command,org.eclipse.ui,3.7.0.I20110602-0100,"org.eclipse.ui.file.save",1419752959330
executed,command,org.eclipse.ui.ide,3.7.0.v20110809-1737,"org.eclipse.jdt.ui.edit.text.java.correction.assist.proposals",1419752965398
deactivated,workbench,org.eclipse.ui.workbench,3.7.0.I20110519-0100,"",1419752966580
activated,workbench,org.eclipse.ui.workbench,3.7.0.I20110519-0100,"",1419752966728
executed,command,org.eclipse.ui,3.7.0.I20110602-0100,"org.eclipse.ui.file.save",1419752975597
executed,command,org.eclipse.ui.ide,3.7.0.v20110809-1737,"org.eclipse.jdt.ui.edit.text.java.correction.assist.proposals",1419752979959
deactivated,workbench,org.eclipse.ui.workbench,3.7.0.I20110519-0100,"",1419752981415
activated,workbench,org.eclipse.ui.workbench,3.7.0.I20110519-0100,"",1419752981557
executed,command,org.eclipse.ui,3.7.0.I20110602-0100,"org.eclipse.ui.file.save",1419752983769
started,bundle,org.eclipse.debug.ui,3.7.101.v20110817_r371,"org.eclipse.debug.ui",1419752987867
started,bundle,org.eclipse.jdt.debug,3.7.1.v20110802_r371,"org.eclipse.jdt.debug",1419752988059
started,bundle,org.eclipse.jdt.debug.ui,3.6.1.v20110803_r371,"org.eclipse.jdt.debug.ui",1419752988244
executed,command,,,"AUTOGEN:::org.eclipse.jdt.debug.CompilationUnitEditor.BreakpointRulerActions/org.eclipse.jdt.debug.ui.actions.ManageBreakpointRulerAction",1419752988329
executed,command,,,"AUTOGEN:::org.eclipse.jdt.debug.CompilationUnitEditor.BreakpointRulerActions/org.eclipse.jdt.debug.ui.actions.ManageBreakpointRulerAction",1419752989973
executed,command,,,"AUTOGEN:::org.eclipse.jdt.debug.CompilationUnitEditor.BreakpointRulerActions/org.eclipse.jdt.debug.ui.actions.ManageBreakpointRulerAction",1419752992396
started,bundle,org.eclipse.wst.server.core,1.1.303.v20110816_1717,"org.eclipse.wst.server.core",1419752993644
started,bundle,org.eclipse.wst.server.ui,1.1.306.v20110823_1704,"org.eclipse.wst.server.ui",1419752993687
started,bundle,org.eclipse.wst.jsdt.debug.rhino.ui,1.0.0.v201103232243,"org.eclipse.wst.jsdt.debug.rhino.ui",1419752993756
started,bundle,org.eclipse.wst.jsdt.core,1.1.101.v201108151912,"org.eclipse.wst.jsdt.core",1419752994285
executed,command,org.eclipse.debug.ui,3.7.101.v20110817_r371,"org.eclipse.debug.ui.commands.DebugLast",1419752995186
opened,view,org.eclipse.debug.ui,3.7.101.v20110817_r371,"org.eclipse.debug.ui.DebugView",1419753000468
activated,view,org.eclipse.debug.ui,3.7.101.v20110817_r371,"org.eclipse.debug.ui.DebugView",1419753000517
activated,editor,org.eclipse.jdt.ui,3.7.1.r371_v20110824-0800,"org.eclipse.jdt.ui.CompilationUnitEditor",1419753001902
executed,command,org.eclipse.debug.ui,3.7.101.v20110817_r371,"org.eclipse.debug.ui.commands.StepOver",1419753007099
executed,command,org.eclipse.debug.ui,3.7.101.v20110817_r371,"org.eclipse.debug.ui.commands.StepInto",1419753027065
opened,editor,org.sf.feeling.decompiler,1.0.3.201211040213,"net.sf.feeling.decompiler.ClassFileEditor",1419753027433
activated,editor,org.sf.feeling.decompiler,1.0.3.201211040213,"net.sf.feeling.decompiler.ClassFileEditor",1419753027544
executed,command,org.eclipse.debug.ui,3.7.101.v20110817_r371,"org.eclipse.debug.ui.commands.Resume",1419753030002
activated,view,org.eclipse.debug.ui,3.7.101.v20110817_r371,"org.eclipse.debug.ui.DebugView",1419753030144
executed,command,org.eclipse.debug.ui,3.7.101.v20110817_r371,"org.eclipse.debug.ui.commands.Resume",1419753030178
opened,view,org.eclipse.ui.console,3.5.100.v20110511,"org.eclipse.ui.console.ConsoleView",1419753030408
activated,view,org.eclipse.ui.console,3.5.100.v20110511,"org.eclipse.ui.console.ConsoleView",1419753030437
activated,editor,org.eclipse.jdt.ui,3.7.1.r371_v20110824-0800,"org.eclipse.jdt.ui.CompilationUnitEditor",1419753032326
deactivated,workbench,org.eclipse.ui.workbench,3.7.0.I20110519-0100,"",1419753033575
activated,workbench,org.eclipse.ui.workbench,3.7.0.I20110519-0100,"",1419754005338
activated,view,org.eclipse.jdt.ui,3.7.1.r371_v20110824-0800,"org.eclipse.jdt.ui.PackageExplorer",1419754008097
deactivated,workbench,org.eclipse.ui.workbench,3.7.0.I20110519-0100,"",1419754014228
activated,workbench,org.eclipse.ui.workbench,3.7.0.I20110519-0100,"",1419754023165
opened,editor,org.eclipse.jdt.ui,3.7.1.r371_v20110824-0800,"org.eclipse.jdt.ui.CompilationUnitEditor",1419754023576
activated,editor,org.eclipse.jdt.ui,3.7.1.r371_v20110824-0800,"org.eclipse.jdt.ui.CompilationUnitEditor",1419754023611
executed,command,org.eclipse.ui,3.7.0.I20110602-0100,"org.eclipse.ui.edit.selectAll",1419754024746
executed,command,org.eclipse.ui,3.7.0.I20110602-0100,"org.eclipse.ui.edit.paste",1419754025303
error,log,,,"Exception occurred during compilation unit conversion:\r\n----------------------------------- SOURCE BEGIN -------------------------------------\r\n\r\n\t\r\nOCPJP 6 Free Mock Exam Practice Questions\r\n\r\n\r\nAre you prepared for OCPJP6 1Z0-851 exam , check your mock score ?\r\nOCPJP6 Practice Test 1Z0-851\r\n\r\nQuestions no -1 \r\nWhat is the output for the below code ?\r\n\r\nclass A implements Runnable{\r\n\tpublic void run(){\r\n\t\tSystem.out.println(Thread.currentThread().getName());\r\n\t}   \r\n}\r\n\r\n\r\npublic class Test {\t\t\r\n\tpublic static void main(String... args) {\t\r\n\t\tA a = new A();\r\n\t\tThread t = new Thread(a);\r\n\t\tThread t1 = new Thread(a);\t\t\r\n\t\tt.setName(""t"");\r\n\t\tt1.setName(""t1"");\r\n\t\tt.setPriority(10);\r\n\t\tt1.setPriority(-3);\r\n\t\tt.start();\r\n\t\tt1.start();\r\n\t\t\r\n\t}\r\n}\r\n\r\n\r\n\r\nOptions are\r\n\r\nA.t t1\r\nB.t1 t\r\nC.t t\r\nD.Compilation succeed but Runtime Exception\r\n\r\nAnswer :\r\nD is the correct answer.\r\n\r\nThread priorities are set using a positive integer, usually between 1 and 10. t1.setPriority(-3); throws java.lang.IllegalArgumentException.\r\n\r\n\r\n\r\nQuestions no -2 \r\nWhat is the output for the below code ?\r\n\r\nclass A implements Runnable{\r\n\tpublic void run(){\r\n\t\tSystem.out.println(Thread.currentThread().getName());\r\n\t}   \r\n}\r\n\r\n1. public class Test {\t\t\r\n2.\tpublic static void main(String... args) {\t\r\n3.\t\tA a = new A();\r\n4.\t\tThread t = new Thread(a);\r\n5.\t\tt.setName(""good"");\r\n6.\t\tt.start();\r\n7.\t}\r\n8. }\r\n\r\n\r\n\r\n\r\nOptions are\r\n\r\nA.good\r\nB.null\r\nC.Compilation fails with an error at line 5\r\nD.Compilation succeed but Runtime Exception\r\n\r\nAnswer :\r\nA is the correct answer.\r\n\r\nThread.currentThread().getName() return name of the current thread.\r\n\r\n\r\nQuestions no -3 \r\nWhat is the output for the below code ?\r\n\r\npublic class Test {\r\n\t\r\n\r\n\tpublic static void main(String[] args) {\r\n\t\tBoolean expr = true;\r\n\t\tif (expr) {\r\n\t\t\tSystem.out.println(""true"");\r\n\t\t} else {\r\n\t\t\tSystem.out.println(""false"");\r\n\t\t}\r\n\t\t\r\n\t}\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\noptions\r\nA)true\r\nB)Compile Error - can't use Boolean object in if().\r\nC)false\r\nD)Compile Properly but Runtime Exception.\r\n\r\nCorrect answer is : A\r\n\r\nExplanations : In the if statement, condition can be Boolean object in jdk1.5 and jdk1.6.\r\nIn the previous version only boolean is allowed.\r\n\r\nQuestions no -4 \r\nWhat is the output for the below code ?\r\n\r\npublic class Test {\r\n\t\r\n\r\n\tpublic static void main(String[] args) {\r\n\t\tList<Integer> list = new ArrayList<Integer>(); \r\n\t\tlist.add(0, 59);\r\n\t\tint total = list.get(0);\r\n\t\tSystem.out.println(total);\r\n\r\n\t\t\r\n\t}\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\noptions\r\nA)59\r\nB)Compile time error, because you have to do int total = ((Integer)(list.get(0))).intValue();\r\nC)Compile time error, because can't add primitive type in List.\r\nD)Compile Properly but Runtime Exception.\r\n\r\nCorrect answer is : A\r\n\r\nExplanations :Manual conversion between primitive types (such as an int) and wrapper classes \r\n\r\n(such as Integer) is necessary when adding a primitive data type to a collection in jdk1.4 but\r\n\r\nThe new autoboxing/unboxing feature eliminates this manual conversion in jdk 1.5 and jdk 1.6.\r\n\r\nQuestions no -3 \r\nWhat is the output for the below code ?\r\n\r\npublic class Test {\r\n\t\r\n\r\n\tpublic static void main(String[] args) {\r\n\t\tInteger i = null;\r\n\t\tint j = i;\r\n\t\tSystem.out.println(j);\r\n\t\t\r\n\t}\r\n\r\n\r\n}\r\n\r\n\r\n\r\noptions\r\nA)0\r\nB)Compile with error \r\nC)null\r\nD)NullPointerException\r\n\r\nCorrect answer is : D\r\n\r\nExplanations :An Integer expression can have a null value. If your program tries to autounbox null,\r\n it will throw a NullPointerException.\r\n\r\nQuestions no -4 \r\nWhat is the output for the below code ?\r\n\r\npublic class Outer {\r\n\tprivate int a = 7;\r\n\t   \r\n\t   class Inner {\r\n\t      public void displayValue() {\r\n\t         System.out.println(""Value of a is "" + a);\r\n\t      }\r\n\t   }\r\n\t}\r\n\r\n\r\npublic class Test {\r\n\t\r\n\tpublic static void main(String... args) throws Exception {\r\n\t\tOuter mo = new Outer();     \r\n\t\t  Outer.Inner inner = mo.new Inner();\r\n\t\t  inner.displayValue();\r\n\r\n\t}\r\n\t\r\n}\r\n\r\n\r\n\r\n\r\noptions\r\nA)Value of a is 7\r\nB)Compile Error - not able to access private member.\r\nC)Runtime Exception\r\nD)Value of a is 8\r\n\r\nCorrect answer is : A\r\n\r\nExplanations : An inner class instance can never stand alone without a direct relationship to an instance of the outer class.\r\n\r\nyou can access the inner class is through a live instance of the outer class.\r\n\r\nInner class can access private member of the outer class.\r\n\r\nQuestions no -5 \r\nWhat is the output for the below code ?\r\n\r\npublic class B {\r\n\t\r\n\tpublic String getCountryName(){\r\n\t\treturn ""USA"";\r\n\t}\r\n\t\r\n\tpublic StringBuffer getCountryName(){\r\n\t\tStringBuffer sb = new StringBuffer();\r\n\t\tsb.append(""UK"");\r\n\t\treturn sb;\r\n\t}\r\n\t\r\n\t\r\n\tpublic static void main(String[] args){\r\n\t\tB b = new B();\r\n\t\tSystem.out.println(b.getCountryName().toString());\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\noptions\r\nA)Compile with error\r\nB)USA\r\nC)UK\r\nD) Runtime Exception\r\n\r\nCorrect answer is : A\r\n\r\nExplanations : You cannot have two methods in the same class with signatures that only differ by return type.\r\n\r\nQuestions no -6\r\nWhat is the output for the below code ?\r\n\r\npublic class C {\r\n\r\n}\r\n\r\npublic class D extends C{\r\n\r\n}\r\n\r\npublic class A {\r\n\t\r\n\tpublic C getOBJ(){\r\n\t\tSystem.out.println(""class A - return C"");\r\n\t\treturn new C();\r\n\t\t\r\n\t}\r\n\r\n}\r\n\r\npublic class B extends A{\r\n\t\r\n\tpublic D getOBJ(){\r\n\t\tSystem.out.println(""class B - return D"");\r\n\t\treturn new D();\r\n\t\t\r\n\t}\r\n\r\n}\r\n\r\npublic class Test {\r\n\r\npublic static void main(String... args) {\r\n     A a = new B();\r\n     a.getOBJ();\r\n\t\r\n     }\r\n}\r\n\r\n\r\n\r\noptions\r\nA)Compile with error - Not allowed to override the return type of a method with a subtype of the original type.\r\nB)class A - return C\r\nC)class B - return D\r\nD) Runtime Exception\r\n\r\nCorrect answer is : C\r\n\r\nExplanations : From J2SE 5.0 onwards. You are now allowed to override the return type of a method with a subtype of the original type.\r\n\r\nQuestions no -7\r\nWhat is the output for the below code ?\r\n\r\npublic class A {\r\n\t\r\n\tpublic String getName() throws ArrayIndexOutOfBoundsException{\r\n\t\treturn ""Name-A"";\r\n\t}\r\n\t\r\n}\r\n\t\r\npublic class C extends A{\r\n\t\r\n\tpublic String getName() throws Exception{\r\n\t\treturn ""Name-C"";\r\n\t}\r\n\r\n}\r\n\t\r\n\t\r\npublic class Test {\r\n\tpublic static void main(String... args) {\r\n\t\tA a = new C();\r\n\t\ta.getName();\r\n\t}\r\n\t\r\n}\r\n\r\n\r\n\r\noptions\r\nA)Compile with error\r\nB)Name-A\r\nC)Name-C\r\nD)Runtime Exception\r\n\r\nCorrect answer is : A\r\n\r\nExplanations : Exception Exception is not compatible with throws clause in A.getName().\r\n\r\nOverridden method should throw only same or sub class of the exception thrown by super class method.\r\n\r\nQuestions no -8 \r\nWhat is the output for the below code ?\r\n\r\nimport java.util.regex.Matcher;\r\nimport java.util.regex.Pattern;\r\n\r\npublic class Test {\r\n\t\r\n\tpublic static void main(String... args) {\r\n            \r\n\t\tPattern p = Pattern.compile(""a*b"");\r\n\t\tMatcher m = p.matcher(""b"");\r\n\t\tboolean b = m.matches();\r\n\t\tSystem.out.println(b);\r\n\r\n\t\t\r\n\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\noptions\r\nA)true\r\nB)Compile Error\r\nC)false\r\nD)b\r\n\r\nCorrect answer is : A\r\n\r\nExplanations : a*b means ""a"" may present zero or more time and ""b"" should be present once.\r\n\r\nQuestions no -9 \r\nWhat is the output for the below code ?\r\n\r\npublic class Test {\r\n\t\r\n\tpublic static void main(String... args) {\r\n            \r\n\t\t\r\n\t\tString input = ""1 fish 2 fish red fish blue fish"";\r\n\t\tScanner s = new Scanner(input).useDelimiter(""\\\\s*fish\\\\s*"");\r\n\t\tSystem.out.println(s.nextInt());\r\n\t\tSystem.out.println(s.nextInt());\r\n\t\tSystem.out.println(s.next());\r\n\t\tSystem.out.println(s.next());\r\n\t\ts.close(); \r\n\t\t\r\n\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\noptions\r\nA)1 2 red blue\r\nB)Compile Error - because Scanner is not defind in java.\r\nC)1 fish 2 fish red fish blue fish\r\nD)1 fish 2 fish red blue fish\r\n\r\nCorrect answer is : A\r\n\r\nExplanations : java.util.Scanner is a simple text scanner which can parse primitive types and strings using regular expressions.\r\n\r\nQuestions no -10 \r\nWhat is the output for the below code ?\r\n\r\npublic class Test {\r\n\t\r\n\tpublic static void main(String... args) {\r\n            \r\n\t\tPattern p = Pattern.compile(""a{3}b?c*"");\r\n\t\tMatcher m = p.matcher(""aaab"");\r\n\t\tboolean b = m.matches();\r\n\t\tSystem.out.println(b);\r\n\r\n\t\t\r\n\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\noptions\r\nA)true\r\nB)Compile Error \r\nC)false\r\nD)NullPointerException\r\n\r\nCorrect answer is : A\r\n\r\nExplanations :\r\nX?  X, once or not at all \r\nX*  X, zero or more times \r\nX+  X, one or more times \r\nX{n}  X, exactly n times \r\nX{n,}  X, at least n times \r\nX{n,m}  X, at least n but not more than m times\r\n\r\nQuestions no -11 \r\nWhat is the output for the below code ?\r\n\r\npublic class Test {\r\n\t\r\n\tpublic static void main(String... args) {\r\n            \r\n\t\tPattern p = Pattern.compile(""a{1,3}b?c*"");\r\n\t\tMatcher m = p.matcher(""aaab"");\r\n\t\tboolean b = m.matches();\r\n\t\tSystem.out.println(b);\r\n\r\n\t\t\r\n\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\noptions\r\nA)true\r\nB)Compile Error \r\nC)false\r\nD)NullPointerException\r\n\r\nCorrect answer is : A\r\n\r\nExplanations :\r\nX?  X, once or not at all \r\nX*  X, zero or more times \r\nX+  X, one or more times \r\nX{n}  X, exactly n times \r\nX{n,}  X, at least n times \r\nX{n,m}  X, at least n but not more than m times\r\n\r\nQuestions no -12 \r\nWhat is the output for the below code ?\r\n\r\npublic class A {\r\n\tpublic A() {\r\n        System.out.println(""A"");\r\n    }\r\n}\r\n\r\npublic class B extends A implements Serializable {\r\n\tpublic B() {\r\n        System.out.println(""B"");\r\n    }\r\n\r\n}\r\n\r\npublic class Test {\r\n\t\r\n\tpublic static void main(String... args) throws Exception {\r\n\t\tB b = new B();\r\n       \r\n        ObjectOutputStream save = new ObjectOutputStream(new FileOutputStream(""datafile""));\r\n        save.writeObject(b); \r\n        save.flush(); \r\n        \r\n\r\n        ObjectInputStream restore = new ObjectInputStream(new FileInputStream(""datafile""));\r\n        B z = (B) restore.readObject();\r\n\r\n        \r\n\r\n\t}\r\n\t\r\n}\r\n\r\n\r\n\r\n\r\noptions\r\nA)A B A\r\nB)A B A B\r\nC)B B\r\nD)A B\r\n\r\nCorrect answer is : A\r\n\r\nExplanations :On the time of deserialization , the Serializable object not create new object. So constructor of class B does not called.\r\n \r\nA is not Serializable object so constructor is called.\r\n\r\nQuestions no -13 \r\nWhat is the output for the below code ?\r\n\r\npublic class A {}\r\n\r\npublic class B implements Serializable  {\r\n\tA a = new A();\r\n\tpublic static void main(String... args){\r\n\t\tB b = new B();\r\n\t\ttry{\r\n\t\t\tFileOutputStream fs = new FileOutputStream(""b.ser"");\r\n\t\t\tObjectOutputStream os = new ObjectOutputStream(fs);\r\n\t\t\tos.writeObject(b);\r\n\t\t\tos.close();\r\n\t\t\t\r\n\t\t}catch(Exception e){\r\n\t\t\te.printStackTrace();\r\n\t\t}\r\n\t\t\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\n\r\noptions\r\nA)Compilation Fail\r\nB)java.io.NotSerializableException:  Because class A is not Serializable.\r\nC)Run properly\r\nD)Compilation Fail :  Because class A is not Serializable.\r\n\r\nCorrect answer is : B\r\n\r\nExplanations :It throws java.io.NotSerializableException:A  Because class A is not Serializable.\r\n\r\nWhen JVM tries to serialize object B it will try to serialize A also because (A a = new A()) is instance variable of Class B.\r\n\r\nSo thows NotSerializableException.\r\n\r\nQuestions no -14 \r\nWhat is the output for the below code running in the same JVM?\r\n\r\npublic class A implements Serializable {\r\n\ttransient int a = 7;\r\n\t  static int b = 9;\r\n\r\n}\r\n\r\npublic class B implements Serializable  {\r\n\t\r\n\tpublic static void main(String... args){\r\n\t\tA a = new A();\r\n\t\ttry {\r\n\t\t      ObjectOutputStream os = new ObjectOutputStream(\r\n\t\t         new FileOutputStream(""test.ser""));\r\n\t\t      os.writeObject(a);  \r\n\t\t      os. close();\r\n\t\t      System.out.print( + + a.b + "" "");\r\n\r\n\t\t      ObjectInputStream is = new ObjectInputStream(new FileInputStream(""test.ser""));\r\n\t\t      A s2 = (A)is.readObject();\r\n\t\t      is.close();\r\n\t\t      System.out.println(s2.a + "" "" + s2.b);\r\n\t\t    } catch (Exception x) \r\n\t\t    {\r\n\t\t    \tx.printStackTrace();\r\n\t\t    }\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\n\r\noptions\r\nA)9 0 9\r\nB)9 7 9\r\nC)0 0 0\r\nD)0 7 0\r\n\r\nCorrect answer is : A\r\n\r\nExplanations :transient variables are not serialized when an object is serialized.\r\n\r\nIn the case of static variable you can get the values in the same JVM. \r\n\r\nQuestions no -15 \r\nWhat is the output for the below code ?\r\n\r\npublic enum Test {\r\n\tBREAKFAST(7, 30), LUNCH(12, 15), DINNER(19, 45);\r\n\t\r\n\tprivate int hh;\r\n\r\n\tprivate int mm;\r\n\r\n\tTest(int hh, int mm) {\r\n\t\tassert (hh >= 0 && hh <= 23) : ""Illegal hour."";\r\n\t\tassert (mm >= 0 && mm <= 59) : ""Illegal mins."";\r\n\t\tthis.hh = hh;\r\n\t\tthis.mm = mm;\r\n\t}\r\n\r\n\tpublic int getHour() {\r\n\t\treturn hh;\r\n\t}\r\n\r\n\tpublic int getMins() {\r\n\t\treturn mm;\r\n\t}\r\n\t\r\n\tpublic static void main(String args[]){\r\n\t\tTest t =  new BREAKFAST;\r\n\t\tSystem.out.println(t.getHour() +"":""+t.getMins());\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\noptions\r\nA)7:30\r\nB)Compile Error - an enum cannot be instantiated using the new operator.\r\nC)12:50\r\nD)19:45\r\n\r\nCorrect answer is : B\r\n\r\nExplanations : As an enum cannot be instantiated using the new operator, the constructors cannot be called explicitly.\r\nYou have to do like \r\nTest t =  BREAKFAST;\r\n\r\nQuestions no -16 \r\nWhat is the output for the below code ?\r\n\r\npublic class Test {\r\n\tenum Day {\r\n\t\tMONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY\r\n\t}\r\n\tenum Month {\r\n\t\tJAN, FEB\r\n\t}\r\n\r\n\tpublic static void main(String[] args) {\r\n\r\n\t\tint[] freqArray = { 12, 34, 56, 23, 5, 13, 78 };\r\n\r\n\t\t// Create a Map of frequencies\r\n\t\tMap<Day, Integer> ordinaryMap = new HashMap<Day, Integer>();\r\n\t\tfor (Day day : Day.values()) {\r\n\t\t\tordinaryMap.put(day, freqArray[day.ordinal()]);\r\n\t\t}\r\n\t\t\r\n\r\n\t\t// Create an EnumMap of frequencies\r\n\t\tEnumMap<Day, Integer> frequencyEnumMap = new EnumMap<Day, Integer>(ordinaryMap);\r\n\r\n\t\t// Change some frequencies\r\n\t\tfrequencyEnumMap.put(null, 100);\r\n\t\t\r\n\t\tSystem.out.println(""Frequency EnumMap: "" + frequencyEnumMap);\r\n\r\n\t\t\r\n\t}\r\n\r\n}\r\n\r\n\r\noptions\r\nA)Frequency EnumMap: {MONDAY=12, TUESDAY=34, WEDNESDAY=56, THURSDAY=23, FRIDAY=5, SATURDAY=13, SUNDAY=78}\r\nB)Compile Error \r\nC)NullPointerException\r\nD)Frequency EnumMap: {MONDAY=100, TUESDAY=34, WEDNESDAY=56, THURSDAY=23, FRIDAY=5, SATURDAY=13, SUNDAY=123}\r\n\r\nCorrect answer is : C\r\n\r\nExplanations : The null reference as a key is NOT permitted.\r\n\r\nQuestions no -17 \r\npublic class EnumTypeDeclarations {\r\n\t\r\n\tpublic void foo() {\r\n\t\t\r\n\t\tenum SimpleMeal { \r\n\t\t\tBREAKFAST, LUNCH, DINNER \r\n\t\t}\r\n\t}\r\n}\r\n\r\nIs the above code Compile without error ?\r\n\r\n\r\noptions\r\nA)Compile without error\r\nB)Compile with error\r\nC)Compile without error but Runtime Exception\r\nD)Compile without error but Enum Exception\r\n\r\nCorrect answer is : B\r\n\r\nExplanations :\r\nAn enum declaration is a special kind of class declaration:\r\n\r\na) It can be declared at the top-level and as static enum declaration. \r\n\r\nb) It is implicitly static, i.e. no outer object is associated with an enum constant. \r\n\r\nc) It is implicitly final unless it contains constant-specific class bodies, but it can implement interfaces. \r\n\r\nd) It cannot be declared abstract unless each abstract method is overridden in the constant-specific class body of every enum constant. \r\n\r\ne) Local (inner) enum declaration is NOT OK! \r\n\r\nHere in\r\npublic void foo() {\r\n\t\t\r\n\t\tenum SimpleMeal { \r\n\t\t\tBREAKFAST, LUNCH, DINNER \r\n\t\t}\r\n\t}\r\n\r\nenum declaration is local within method so compile time error.\r\n\r\nQuestions no -18 \r\nWhat is the output for the below code ?\r\n\r\npublic enum Test {\r\n\tint t;\r\n\tBREAKFAST(7, 30), LUNCH(12, 15), DINNER(19, 45);\r\n\t\r\n\tprivate int hh;\r\n\r\n\tprivate int mm;\r\n\r\n\tTest(int hh, int mm) {\r\n\t\tassert (hh >= 0 && hh <= 23) : ""Illegal hour."";\r\n\t\tassert (mm >= 0 && mm <= 59) : ""Illegal mins."";\r\n\t\tthis.hh = hh;\r\n\t\tthis.mm = mm;\r\n\t}\r\n\r\n\tpublic int getHour() {\r\n\t\treturn hh;\r\n\t}\r\n\r\n\tpublic int getMins() {\r\n\t\treturn mm;\r\n\t}\r\n\t\r\n\tpublic static void main(String args[]){\r\n\t\tTest t =  BREAKFAST;\r\n\t\tSystem.out.println(t.getHour() +"":""+t.getMins());\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\noptions\r\nA)7:30\r\nB)Compile Error \r\nC)12:15\r\nD)19:45\r\n\r\nCorrect answer is : B\r\n\r\nExplanations : The enum constants must be declared before any other declarations in an enum type.\r\n\r\nIn this case compile error because of declaration int t; before enum declaration.\r\n\r\nQuestions no -19 \r\nWhat is the output for the below code ?\r\n\r\npublic class B extends Thread{\r\npublic static void main(String argv[]){\r\nB b = new B();\r\nb.run();\r\n} \r\npublic void start(){\r\nfor (int i = 0; i < 10; i++){\r\nSystem.out.println(""Value of i = "" + i); \r\n}  \r\n}\r\n}\r\n\r\n\r\n\r\n\r\noptions\r\nA)A compile time error indicating that no run method is defined for the Thread class\r\nB)A run time error indicating that no run method is defined for the Thread class\r\nC)Clean compile and at run time the values 0 to 9 are printed out\r\nD)Clean compile but no output at runtime\r\n\r\nCorrect answer is : D\r\n\r\nExplanations : This is a bit of a sneaky one as I have swapped around the names of the methods you need to define and call when running a thread.\r\n If the for loop were defined in a method called public void run() and the call in the main method had been to b.start() The list of values from 0 to 9 \r\nwould have been output.\r\n\r\nQuestions no -20 \r\n\r\nWhat is the output for the below code ?\r\n\r\npublic class Test extends Thread{\r\n\r\n    static String sName = ""good"";\r\n    public static void main(String argv[]){\r\n    \tTest t = new Test();\r\n    t.nameTest(sName);\r\n    System.out.println(sName);\r\n    \r\n    }\r\n    public void nameTest(String sName){\r\n            sName = sName + "" idea "";\r\n             start();\r\n    }\r\n    public void run(){\r\n    \r\n    for(int i=0;i  <  4; i++){\r\n            sName = sName + "" "" + i;\r\n            \r\n    }\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n\r\noptions\r\nA)good\r\nB)good idea\r\nC)good idea good idea\r\nD)good 0 good 0 1\r\n\r\nCorrect answer is : A\r\n\r\nExplanations : Change value in local methods wouldn’t change in global in case of String ( because String object is immutable).\r\n\r\nQuestions no -21 \r\nWhat is the output for the below code ?\r\n\r\npublic class Test{\r\n\tpublic static void main(String argv[]){\r\n\tTest1 pm1 = new Test1(""One"");\r\n\tpm1.run();\r\n\tTest1 pm2 = new Test1(""Two"");\r\n\tpm2.run();\r\n\r\n\t}\r\n}\r\n\r\nclass Test1 extends Thread{\r\nprivate String sTname="""";\r\nTest1(String s){\r\n\tsTname = s;\r\n\r\n}\r\npublic void run(){\r\n\tfor(int i =0; i < 2 ; i++){\r\n\t\ttry{\r\n\t\t sleep(1000);\r\n\t\t}catch(InterruptedException e){}\r\n\r\n\t\tyield();\r\n\t\tSystem.out.println(sTname);\r\n\t\t}\r\n\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\noptions\r\nA)Compile error\r\nB)One One Two Two\r\nC)One Two One Two\r\nD)One Two\r\n\r\nCorrect answer is : B\r\n\r\nExplanations : If you call the run method directly it just acts as any other method and does not return to the calling code until it has finished. executing\r\n\r\nQuestions no -22 \r\nWhat is the output for the below code ?\r\n\r\npublic class Test extends Thread{\r\n    public static void main(String argv[]){\r\n        Test  b = new Test();\r\n        b.start();\r\n    }\r\n    public void run(){      \r\n        System.out.println(""Running"");\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\noptions\r\nA)Compilation clean and run but no output\r\nB)Compilation and run with the output ""Running""\r\nC)Compile time error with complaint of no Thread import\r\nD)Compile time error with complaint of no access to Thread package\r\n\r\nCorrect answer is : B\r\n\r\nExplanations :\r\nThe Thread class is part of the core java.lang package and does not need any explicit import statement.\r\n\r\nQuestions no -23 \r\nWhat is the output for the below code ?\r\n\r\npublic class Tech {\r\n\t public void tech() {\r\n\t      System.out.println(""Tech"");\r\n\t   }\r\n\r\n}\r\n\r\n\r\npublic class Atech {\r\n\r\n\tTech a = new Tech() {\t      \r\n\t      public void tech() {\r\n\t         System.out.println(""anonymous tech"");\r\n\t      }\r\n\t   };\r\n\t   \r\n\t   public void dothis() {\r\n\t\t      a.tech();     \r\n\t\t      \r\n\t\t   }\r\n\r\npublic static void main(String... args){\r\n\tAtech atech = new Atech();\r\n\tatech.dothis();\r\n}\r\n\r\n\r\n\r\n\r\noptions\r\nA)anonymous tech\r\nB)Compile Error \r\nC)Tech\r\nD)anonymous tech Tech\r\n\r\nCorrect answer is : A\r\n\r\nExplanations : This is anonymous subclass of the specified class type.\r\n\r\nAnonymous inner class ( anonymous subclass ) overriden the Tech super class of tech() method.\r\n\r\nTherefore Subclass method will get called.\r\n\r\nQuestions no -24 \r\nWhat is the output for the below code ?\r\n\r\npublic class Outer {\r\n\t private String x = ""Outer variable"";\r\n\t   void doStuff() {\r\n\t     String z = ""local variable"";\r\n\t     class Inner {\r\n\t       public void seeOuter() {\r\n\t         System.out.println(""Outer x is "" + x);\r\n\t         System.out.println(""Local variable z is "" + z);  \r\n\t       } \r\n\t     }   \r\n\t   }  \r\n\t   \r\n\t  \r\n}\r\n\r\n\r\n\r\n\r\noptions\r\nA)Outer x is Outer variable.\r\nB)Compile Error \r\nC)Local variable z is local variable.\r\nD)Outer x is Outer variable Local variable z is local variable\r\n\r\nCorrect answer is : B\r\n\r\nExplanations : Cannot refer to a non-final variable z inside an inner class defined in a different method.\r\n\r\nQuestions no -25\r\n\r\nWhat is the output for the below code ?\r\n\r\npublic class Test {\r\n\t\r\n\tpublic static void main(String... args) {\r\n\t\tfor(int i = 2; i < 4; i++)\r\n  for(int j = 2; j < 4; j++)\r\n     assert i!=j : i; \r\n\r\n\r\n\t}\r\n}\r\n\r\noptions\r\nA)The class compiles and runs, but does not print anything.\r\nB)The number 2 gets printed with AssertionError\r\nC)The number 3 gets printed with AssertionError\r\nD)compile error\r\n\r\nCorrect answer is : B\r\n\r\nExplanations : When i and j are both 2, assert condition is false, and AssertionError gets generated. \r\n\r\nQuestions no -26\r\n\r\nWhat is the output for the below code ?\r\n\r\npublic class Test {\r\n\t\r\n\tpublic static void main(String... args) {\r\n\t\tfor(int i = 2; i < 4; i++)\r\n  for(int j = 2; j < 4; j++)\r\n\tif(i < j)\r\n     assert i!=j : i; \r\n\r\n\r\n\t}\r\n}\r\n\r\noptions\r\nA)The class compiles and runs, but does not print anything.\r\nB)The number 2 gets printed with AssertionError\r\nC)The number 3 gets printed with AssertionError\r\nD)compile error\r\n\r\nCorrect answer is : A\r\n\r\nExplanations : When if condition returns true, the assert statement also returns true.\r\nHence AssertionError not generated.\r\n\r\nQuestions no -26 \r\nWhat is the output for the below code ?\r\n\r\npublic class NameBean {\r\n\tprivate String str;\r\n\t\r\n\tNameBean(String str ){\r\n\t\tthis.str = str;\r\n\t}\r\n\t\r\n\tpublic String toString() {\r\n\t\treturn str;\r\n\t}\r\n}\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\r\nimport java.util.HashSet;\r\n\r\npublic class CollClient {\r\n\t\r\n\tpublic static void main(String ... sss) {\r\n\t\tHashSet myMap = new HashSet();\r\n\t\tString s1 = new String(""das"");\r\n\t\tString s2 = new String(""das"");\r\n\tNameBean s3 = new NameBean(""abcdef"");\r\n\tNameBean s4 = new NameBean(""abcdef"");\r\n\t\t\r\n\t\tmyMap.add(s1);\r\n\t\tmyMap.add(s2);\r\n\t\tmyMap.add(s3);\r\n\t\tmyMap.add(s4);\r\n\t\t\r\n\t\tSystem.out.println(myMap);\r\n\t}\t\r\n}\r\n\r\n\r\n\r\n\r\noptions\r\nA)das abcdef abcdef\r\nB)das das abcdef abcdef\r\nC)das abcdef\r\nD)abcdef abcdef\r\n\r\nCorrect answer is : A\r\n\r\nExplanations : Need to implement 'equals' and 'hashCode' methods to get unique Set for user defind objects(NameBean).\r\n\r\nString object internally implements 'equals' and 'hashCode' methods therefore Set only stored one value.\r\n\r\nQuestions no -27 \r\nSynchronized resizable-array implementation of the List interface is _____________?\r\n\r\n\r\n\r\n\r\noptions\r\nA)Vector\r\nB)ArrayList\r\nC)Hashtable\r\nD)HashMap\r\n\r\nCorrect answer is : A\r\n\r\nExplanations : Vector implements List, RandomAccess - Synchronized resizable-array implementation of the List interface with additional ""legacy methods.""\r\n\r\nQuestions no -28 \r\nWhat is the output for the below code ?\r\npublic class Test {\r\n\r\n    \r\n    public static void main(String argv[]){\r\n    \t \r\n    \tArrayList list = new ArrayList(); \r\n    \tArrayList<String> listStr = list; \r\n    \tArrayList<StringBuffer> listBuf = list; \r\n    \tlistStr.add(0, ""Hello""); \r\n    \tStringBuffer buff = listBuf.get(0); \r\n       System.out.println(buff.toString());\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n\r\noptions\r\nA)Hello\r\nB)Compile error\r\nC)java.lang.ClassCastException\r\nD)null\r\n\r\nCorrect answer is : C\r\n\r\nExplanations : java.lang.String cannot be cast to java.lang.StringBuffer at the code StringBuffer buff = listBuf.get(0); \r\nSo thows java.lang.ClassCastException.\r\n\r\nQuestions no -29 \r\nWhat is the output for the below code ?\r\n\r\nimport java.util.LinkedList;\r\nimport java.util.Queue;\r\n\r\n\r\npublic class Test {\r\n\tpublic static void main(String... args) {\r\n        \r\n\t\t\r\n\t\t\r\n\t\tQueue<String> q = new LinkedList<String>();\r\n\t\t        q.add(""newyork"");\r\n\t\t        q.add(""ca"");\r\n\t\t        q.add(""texas"");\r\n\t\t        show(q);\r\n\t\t    }\r\n\t\t\r\n\t\t    public static void show(Queue q) {\r\n\t\t        q.add(new Integer(11));\r\n\t\t        while (!q.isEmpty ( ) )\r\n\t\t            System.out.print(q.poll() + ""  "");\r\n\t\t    }\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\noptions\r\nA)Compile error : Integer can't add\r\nB)newyork  ca  texas  11\r\nC)newyork  ca  texas\r\nD)newyork  ca \r\n\r\nCorrect answer is : B\r\n\r\nExplanations : \r\nq was originally declared as Queue<String>, But in show() method it is passed as an untyped Queue. nothing in the compiler or JVM prevents us from adding an Integer after that.\r\nIf the show method signature is public static void show(Queue<String> q) than you can't add Integer, Only String allowed. But public static void show(Queue q) is untyped Queue so you can add Integer.\r\npoll() Retrieves and removes the head of this queue, or returns null if this queue is empty.\r\n\r\nQuestions no -30 \r\nWhat is the output for the below code ?\r\n\r\npublic interface TestInf {\r\n int i =10;\r\n}\r\n\r\npublic class Test {\r\n\tpublic static void main(String... args) {\r\n\t\tTestInf.i=12;\r\n\t\tSystem.out.println(TestInf.i);\r\n\t\r\n\t}\r\n\t\r\n\t\r\n\t\r\n}\r\n\r\n\r\n\r\noptions\r\nA)Compile with error\r\nB)10\r\nC)12\r\nD) Runtime Exception\r\n\r\nCorrect answer is : A\r\n\r\nExplanations : All the variables declared in interface is Implicitly static and final , therefore can't change the value.\r\n\r\nQuestions no -31 \r\nWhat is the output for the below code ?\r\n\r\npublic class Test {\r\n            static { int a = 5; }\r\n            public static void main(String[] args){\r\n            System.out.println(a);\r\n            }\r\n          }\r\n\r\n\r\n\r\noptions\r\nA)Compile with error\r\nB)5\r\nC)0\r\nD) Runtime Exception\r\n\r\nCorrect answer is : A\r\n\r\nExplanations : A variable declared  in a static initialiser is not accessible outside its enclosing block.\r\n\r\nQuestions no -32 \r\nWhat is the output for the below code ?\r\n\r\nclass A {\r\n  { System.out.print(""b1 ""); }\r\n  public A() { System.out.print(""b2 ""); }\r\n}\r\nclass B extends A {\r\n  static { System.out.print(""r1 ""); }\r\n  public B() { System.out.print(""r2 ""); }\r\n  { System.out.print(""r3 ""); }\r\n  static { System.out.print(""r4 ""); }\r\n}\r\nclass C extends B {\r\n  public static void main(String[] args) {\r\n    System.out.print(""pre "");\r\n    new C();\r\n    System.out.println(""post "");\r\n  }\r\n}\r\n\r\n\r\n\r\noptions\r\nA)r1 r4 pre b1 b2 r3 r2 post\r\nB)r1 r4 pre b1 b2  post\r\nC)r1 r4 pre b1 b2  post r3 r2\r\nD)pre r1 r4  b1 b2  r2 r3 post\r\n\r\nCorrect answer is : A\r\n\r\nExplanations : All static blocks execute first then blocks and constructor. \r\n\r\nBlocks and constructor executes (super class block then super class constructor, sub class block then sub class constructor).\r\n\r\nSequence for static blocks is super class first then sub class.\r\n\r\nSequence for blocks is super class first then sub class.\r\n\r\n\r\nQuestions no -33 \r\nWhat is the output for the below code ?\r\n\r\npublic class Test {\r\n\t\r\n\tpublic static void main(String... args) throws Exception {\r\n\t\tInteger i = 34;\r\n\t\tint l = 34;\r\n\t\tif(i.equals(l)){\r\n\t\t\tSystem.out.println(true);\r\n\t\t}else{\r\n\t\t\tSystem.out.println(false);\r\n\t\t}\r\n\r\n\t}\r\n\t\r\n}\r\n\r\n\r\n\r\noptions\r\nA)true\r\nB)false\r\nC)Compile Error\r\nD) Runtime Exception\r\n\r\nCorrect answer is : A\r\n\r\nExplanations : equals() method for the integer wrappers will only return true if the two primitive types and the two values are equal.\r\n\r\nQuestions no -34 \r\nWhich statement is true about outer class?\r\n\r\n\r\n\r\noptions\r\nA)outer class can only declare public , abstract and final\r\nB)outer class may be private\r\nC)outer class can't be abstract\r\nD)outer class can be static\r\n\r\nCorrect answer is : A\r\n\r\nExplanations : outer class can only declare public , abstract and final.\r\n\r\nQuestions no -35 \r\n\r\nWhat is the output for the below code ?\r\n\r\nstatic public class Test {\r\n\tpublic static void main(String[] args) {\r\n\t\t  char c = 'a';\r\n\t\r\n\t\t switch(c){\r\n\t\t     case 65:\r\n\t\t              System.out.println(""one"");break;\r\n\t\t     case 'a':\r\n\t\t              System.out.println(""two"");break;\r\n\t\t     case 3:\r\n\t\t              System.out.println(""three"");\r\n\t\t}\r\n\t\t\r\n\t\t}\r\n\t\r\n\r\n}\r\n\r\n\r\n\r\noptions\r\nA)one\r\nB)two\r\nC)Compile error - char can't be permitted in switch statement \r\nD)Compile error - Illegal modifier for the class Test; only public, abstract & final are permitted.\r\n\r\n\r\nCorrect answer is : D\r\n\r\nExplanations : outer class can only declare public , abstract and final.\r\nIllegal modifier for the class Test; only public, abstract & final are permitted\r\n\r\nQuestions no -36\r\n\r\nWhat is the output for the below code ?\r\n\r\npublic class Test {\r\n\t\r\n\tpublic static void main(String... args) {\r\n\t\tArrayList<Integer> list = new ArrayList<Integer>();\r\n\t\tlist.add(1);\r\n\t\tlist.add(2);\r\n\t\tlist.add(3);\r\n\t\t\r\n\t\tfor(int i:list)\r\n\t\t\tSystem.out.println(i);\r\n\t\t\r\n\r\n\t}\r\n}\r\n\r\noptions\r\nA)1 2 3\r\nB)Compile error , can't add primitive type in ArrayList\r\nC)Compile error on for(int i:list) , Incorrect Syntax\r\nD)0 0 0\r\n\r\nCorrect answer is : A\r\n\r\nExplanations : JDK 1.5, 1.6 allows add primitive type in ArrayList  and for(int i:list) syntax is also correct.\r\nfor(int i:list) is same as \r\nfor(int i=0; i < list.size();i++){\r\n\t\t\tint a = list.get(i);\r\n\t\t\t\r\n\t\t}\r\n\r\nQuestions no -37 \r\nWhat is the output for the below code ?\r\n\r\npublic class SuperClass {\r\n\tpublic int doIt(String str, Integer... data)throws ArrayIndexOutOfBoundsException{\r\n\t\tString signature = ""(String, Integer[])"";\r\n\t\tSystem.out.println(str + ""  "" + signature);\r\n\t\treturn 1;\r\n\t}\r\n\r\n}\r\n\r\n\r\npublic class SubClass extends SuperClass{\r\n\r\n\tpublic int doIt(String str, Integer... data) throws Exception\r\n\t{\r\n\t\tString signature = ""(String, Integer[])"";\r\n\t\tSystem.out.println(""Overridden: "" + str + "" "" + signature);\r\n\t\treturn 0;\r\n\t}\r\n\t\r\n\tpublic static void main(String... args)\r\n\t{\r\n\t\tSuperClass sb = new SubClass();\r\n\t\ttry{\r\n\t\t\tsb.doIt(""hello"", 3);\r\n\t\t}catch(Exception e){\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t}\r\n\t\r\n}\r\n\r\n\r\n\r\noptions\r\nA)Overridden: hello (String, Integer[])\r\nB)hello (String, Integer[])\r\nC)This code throws an Exception at Runtime\r\nD)Compile with error\r\n\r\nCorrect answer is : D\r\n\r\nExplanations : Exception Exception is not compatible with throws clause in SuperClass.doIt(String, Integer[]). \r\nThe same exception or subclass of that exception is allowed.\r\n\r\nQuestions no -38\r\nWhat is the result of executing the following code, using the parameters 0 and 3 ?\r\n\r\npublic void divide(int a, int b) {\r\n\ttry {\r\n\t\tint c = a / b;\r\n\t} catch (Exception e) {\r\n\t\tSystem.out.print(""Exception "");\r\n\t} finally {\r\n\t\tSystem.out.println(""Finally"");\r\n}\r\n\r\n\r\n\r\noptions\r\nA)Prints out: Exception Finally\r\nB)Prints out: Finally\r\nC)Prints out: Exception\r\nD)Compile with error\r\n\r\nCorrect answer is : B\r\n\r\nExplanations : finally block always executed whether exception occurs or not. \r\n\t0/3 = 0 Does not throws exception.\r\n\r\nQuestions no -39\r\nWhich of the below statement is true about Error?\r\n\r\n\r\n\r\noptions\r\nA)An Error is a subclass of Throwable\r\nB)An Error is a subclass of Exception\r\nC)Error indicates serious problems that a reasonable application should not try to catch.\r\nD)An Error is a subclass of IOException\r\n\r\nCorrect answer is : A and C\r\n\r\nExplanations : An Error is a subclass of Throwable that indicates serious problems that a reasonable application should not try to catch.\r\n\r\nQuestions no -40\r\nWhich of the following is type of RuntimeException?\r\n\r\n\r\n\r\n\r\n\r\noptions\r\nA)IOException\r\nB)ArrayIndexOutOfBoundsException\r\nC)Exception\r\nD)Error\r\n\r\nCorrect answer is : B\r\n\r\nExplanations : Below is the tree.\r\njava.lang.Object\r\n  java.lang.Throwable\r\n      java.lang.Exception\r\n          java.lang.RuntimeException\r\n              java.lang.IndexOutOfBoundsException\r\n                  java.lang.ArrayIndexOutOfBoundsException\r\n\r\nQuestions no -41 \r\nWhat is the output for the below code ?\r\n\r\npublic class Test {\r\n\t\r\n\tpublic static void main(String... args) throws Exception {\r\n\t\t File file = new File(""test.txt"");  \r\n\t\t System.out.println(file.exists());\r\n\t\t FileWriter fw = new FileWriter(file); \r\n\t\t System.out.println(file.exists());\r\n\t}\r\n\t\r\n}\r\n\r\n\r\n\r\n\r\noptions\r\nA)true true\r\nB)false false\r\nC)false true\r\nD)true false\r\n\r\nCorrect answer is : C\r\n\r\nExplanations :Creating a new instance of the class File, you're not yet making an actual file, you're just creating a filename.\r\n\r\nSo file.exists() return false.\r\n\r\nFileWriter fw = new FileWriter(file) do three things:\r\n\r\nIt created a FileWriter reference variable fw.\r\n\r\nIt created a FileWriter object, and assigned it to fw.\r\n\r\nIt created an actual empty file out on the disk.\r\n\r\nSo file.exists() return true.\r\n\r\nQuestions no -42 \r\nWhen comparing java.io.BufferedWriter and java.io.FileWriter, which capability exist as a method in only one of two ?\r\n\r\n\r\n\r\n\r\noptions\r\nA)closing the stream\r\nB)flushing the stream\r\nC)writting to the stream\r\nD)writting a line separator to the stream\r\n\r\nCorrect answer is : D\r\n\r\nExplanations :A newLine() method is provided in BufferedWriter which is not in FileWriter.\r\n\r\nQuestions no -43 \r\nWhat is the output for the below code ?\r\npublic class Test{\r\n\r\npublic static void main(String[] args) {\r\n  int i1=1;\r\n switch(i1){\r\n     case 1:\r\n              System.out.println(""one"");\r\n     case 2:\r\n              System.out.println(""two"");\r\n     case 3:\r\n              System.out.println(""three"");\r\n}\r\n}\r\n}\r\n\r\n\r\noptions\r\nA)one two three\r\nB)one\r\nC)one two\r\nD)Compile error.\r\n\r\nCorrect answer is : A\r\n\r\nExplanations : There is no break statement in case 1 so it causes the below case statements to execute regardless of their values.\r\n\r\nQuestions no -44 \r\nWhat is the output for the below code ?\r\npublic class Test {\r\n\tpublic static void main(String[] args) {\r\n\t\t  char c = 'a';\r\n\t\r\n\t\t switch(c){\r\n\t\t     case 65:\r\n\t\t              System.out.println(""one"");break;\r\n\t\t     case 'a':\r\n\t\t              System.out.println(""two"");break;\r\n\t\t     case 3:\r\n\t\t              System.out.println(""three"");\r\n\t\t}\r\n\t\t\r\n\t\t}\r\n\t\r\n\r\n}\r\n\r\n\r\noptions\r\nA)one two three\r\nB)one\r\nC)two\r\nD)Compile error - char can't be in switch statement.\r\n\r\nCorrect answer is : C\r\n\r\nExplanations : Compile properly and print two.\r\n\r\nQuestions no -45 \r\nWhat is the output for the below code ?\r\n\r\nimport java.util.NavigableMap;\r\nimport java.util.concurrent.ConcurrentSkipListMap;\r\n\r\n\r\npublic class Test {\r\n\tpublic static void main(String... args) {\r\n        \r\n\t\t\r\n\t\tNavigableMap <Integer, String>navMap = new \r\n        ConcurrentSkipListMap<Integer, String>();\r\n\t\t\r\n\t\tnavMap.put(4, ""April"");\r\n\t\tnavMap.put(5, ""May"");\r\n\t\tnavMap.put(6, ""June"");\r\n\t\tnavMap.put(1, ""January"");\r\n\t\tnavMap.put(2, ""February"");\r\n\t\tnavMap.put(3, ""March"");\r\n\r\n        navMap.pollFirstEntry();\r\n        navMap.pollLastEntry();\r\n        navMap.pollFirstEntry();\r\n        System.out.println(navMap.size());\r\n\r\n\r\n\t     \t      \r\n\t}\r\n}\r\n----------------------------------- SOURCE END -------------------------------------",1419754026414
error,log,,,"Problems occurred when invoking code from plug-in: ""org.eclipse.jdt.ui"".",1419754026419
error,log,,,"Error in JDT Core during reconcile",1419754026424
error,log,,,"Exception occurred during compilation unit conversion:\r\n----------------------------------- SOURCE BEGIN -------------------------------------\r\n\r\n\t\r\nOCPJP 6 Free Mock Exam Practice Questions\r\n\r\n\r\nAre you prepared for OCPJP6 1Z0-851 exam , check your mock score ?\r\nOCPJP6 Practice Test 1Z0-851\r\n\r\nQuestions no -1 \r\nWhat is the output for the below code ?\r\n\r\nclass A implements Runnable{\r\n\tpublic void run(){\r\n\t\tSystem.out.println(Thread.currentThread().getName());\r\n\t}   \r\n}\r\n\r\n\r\npublic class Test {\t\t\r\n\tpublic static void main(String... args) {\t\r\n\t\tA a = new A();\r\n\t\tThread t = new Thread(a);\r\n\t\tThread t1 = new Thread(a);\t\t\r\n\t\tt.setName(""t"");\r\n\t\tt1.setName(""t1"");\r\n\t\tt.setPriority(10);\r\n\t\tt1.setPriority(-3);\r\n\t\tt.start();\r\n\t\tt1.start();\r\n\t\t\r\n\t}\r\n}\r\n\r\n\r\n\r\nOptions are\r\n\r\nA.t t1\r\nB.t1 t\r\nC.t t\r\nD.Compilation succeed but Runtime Exception\r\n\r\nAnswer :\r\nD is the correct answer.\r\n\r\nThread priorities are set using a positive integer, usually between 1 and 10. t1.setPriority(-3); throws java.lang.IllegalArgumentException.\r\n\r\n\r\n\r\nQuestions no -2 \r\nWhat is the output for the below code ?\r\n\r\nclass A implements Runnable{\r\n\tpublic void run(){\r\n\t\tSystem.out.println(Thread.currentThread().getName());\r\n\t}   \r\n}\r\n\r\n1. public class Test {\t\t\r\n2.\tpublic static void main(String... args) {\t\r\n3.\t\tA a = new A();\r\n4.\t\tThread t = new Thread(a);\r\n5.\t\tt.setName(""good"");\r\n6.\t\tt.start();\r\n7.\t}\r\n8. }\r\n\r\n\r\n\r\n\r\nOptions are\r\n\r\nA.good\r\nB.null\r\nC.Compilation fails with an error at line 5\r\nD.Compilation succeed but Runtime Exception\r\n\r\nAnswer :\r\nA is the correct answer.\r\n\r\nThread.currentThread().getName() return name of the current thread.\r\n\r\n\r\nQuestions no -3 \r\nWhat is the output for the below code ?\r\n\r\npublic class Test {\r\n\t\r\n\r\n\tpublic static void main(String[] args) {\r\n\t\tBoolean expr = true;\r\n\t\tif (expr) {\r\n\t\t\tSystem.out.println(""true"");\r\n\t\t} else {\r\n\t\t\tSystem.out.println(""false"");\r\n\t\t}\r\n\t\t\r\n\t}\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\noptions\r\nA)true\r\nB)Compile Error - can't use Boolean object in if().\r\nC)false\r\nD)Compile Properly but Runtime Exception.\r\n\r\nCorrect answer is : A\r\n\r\nExplanations : In the if statement, condition can be Boolean object in jdk1.5 and jdk1.6.\r\nIn the previous version only boolean is allowed.\r\n\r\nQuestions no -4 \r\nWhat is the output for the below code ?\r\n\r\npublic class Test {\r\n\t\r\n\r\n\tpublic static void main(String[] args) {\r\n\t\tList<Integer> list = new ArrayList<Integer>(); \r\n\t\tlist.add(0, 59);\r\n\t\tint total = list.get(0);\r\n\t\tSystem.out.println(total);\r\n\r\n\t\t\r\n\t}\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\noptions\r\nA)59\r\nB)Compile time error, because you have to do int total = ((Integer)(list.get(0))).intValue();\r\nC)Compile time error, because can't add primitive type in List.\r\nD)Compile Properly but Runtime Exception.\r\n\r\nCorrect answer is : A\r\n\r\nExplanations :Manual conversion between primitive types (such as an int) and wrapper classes \r\n\r\n(such as Integer) is necessary when adding a primitive data type to a collection in jdk1.4 but\r\n\r\nThe new autoboxing/unboxing feature eliminates this manual conversion in jdk 1.5 and jdk 1.6.\r\n\r\nQuestions no -3 \r\nWhat is the output for the below code ?\r\n\r\npublic class Test {\r\n\t\r\n\r\n\tpublic static void main(String[] args) {\r\n\t\tInteger i = null;\r\n\t\tint j = i;\r\n\t\tSystem.out.println(j);\r\n\t\t\r\n\t}\r\n\r\n\r\n}\r\n\r\n\r\n\r\noptions\r\nA)0\r\nB)Compile with error \r\nC)null\r\nD)NullPointerException\r\n\r\nCorrect answer is : D\r\n\r\nExplanations :An Integer expression can have a null value. If your program tries to autounbox null,\r\n it will throw a NullPointerException.\r\n\r\nQuestions no -4 \r\nWhat is the output for the below code ?\r\n\r\npublic class Outer {\r\n\tprivate int a = 7;\r\n\t   \r\n\t   class Inner {\r\n\t      public void displayValue() {\r\n\t         System.out.println(""Value of a is "" + a);\r\n\t      }\r\n\t   }\r\n\t}\r\n\r\n\r\npublic class Test {\r\n\t\r\n\tpublic static void main(String... args) throws Exception {\r\n\t\tOuter mo = new Outer();     \r\n\t\t  Outer.Inner inner = mo.new Inner();\r\n\t\t  inner.displayValue();\r\n\r\n\t}\r\n\t\r\n}\r\n\r\n\r\n\r\n\r\noptions\r\nA)Value of a is 7\r\nB)Compile Error - not able to access private member.\r\nC)Runtime Exception\r\nD)Value of a is 8\r\n\r\nCorrect answer is : A\r\n\r\nExplanations : An inner class instance can never stand alone without a direct relationship to an instance of the outer class.\r\n\r\nyou can access the inner class is through a live instance of the outer class.\r\n\r\nInner class can access private member of the outer class.\r\n\r\nQuestions no -5 \r\nWhat is the output for the below code ?\r\n\r\npublic class B {\r\n\t\r\n\tpublic String getCountryName(){\r\n\t\treturn ""USA"";\r\n\t}\r\n\t\r\n\tpublic StringBuffer getCountryName(){\r\n\t\tStringBuffer sb = new StringBuffer();\r\n\t\tsb.append(""UK"");\r\n\t\treturn sb;\r\n\t}\r\n\t\r\n\t\r\n\tpublic static void main(String[] args){\r\n\t\tB b = new B();\r\n\t\tSystem.out.println(b.getCountryName().toString());\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\noptions\r\nA)Compile with error\r\nB)USA\r\nC)UK\r\nD) Runtime Exception\r\n\r\nCorrect answer is : A\r\n\r\nExplanations : You cannot have two methods in the same class with signatures that only differ by return type.\r\n\r\nQuestions no -6\r\nWhat is the output for the below code ?\r\n\r\npublic class C {\r\n\r\n}\r\n\r\npublic class D extends C{\r\n\r\n}\r\n\r\npublic class A {\r\n\t\r\n\tpublic C getOBJ(){\r\n\t\tSystem.out.println(""class A - return C"");\r\n\t\treturn new C();\r\n\t\t\r\n\t}\r\n\r\n}\r\n\r\npublic class B extends A{\r\n\t\r\n\tpublic D getOBJ(){\r\n\t\tSystem.out.println(""class B - return D"");\r\n\t\treturn new D();\r\n\t\t\r\n\t}\r\n\r\n}\r\n\r\npublic class Test {\r\n\r\npublic static void main(String... args) {\r\n     A a = new B();\r\n     a.getOBJ();\r\n\t\r\n     }\r\n}\r\n\r\n\r\n\r\noptions\r\nA)Compile with error - Not allowed to override the return type of a method with a subtype of the original type.\r\nB)class A - return C\r\nC)class B - return D\r\nD) Runtime Exception\r\n\r\nCorrect answer is : C\r\n\r\nExplanations : From J2SE 5.0 onwards. You are now allowed to override the return type of a method with a subtype of the original type.\r\n\r\nQuestions no -7\r\nWhat is the output for the below code ?\r\n\r\npublic class A {\r\n\t\r\n\tpublic String getName() throws ArrayIndexOutOfBoundsException{\r\n\t\treturn ""Name-A"";\r\n\t}\r\n\t\r\n}\r\n\t\r\npublic class C extends A{\r\n\t\r\n\tpublic String getName() throws Exception{\r\n\t\treturn ""Name-C"";\r\n\t}\r\n\r\n}\r\n\t\r\n\t\r\npublic class Test {\r\n\tpublic static void main(String... args) {\r\n\t\tA a = new C();\r\n\t\ta.getName();\r\n\t}\r\n\t\r\n}\r\n\r\n\r\n\r\noptions\r\nA)Compile with error\r\nB)Name-A\r\nC)Name-C\r\nD)Runtime Exception\r\n\r\nCorrect answer is : A\r\n\r\nExplanations : Exception Exception is not compatible with throws clause in A.getName().\r\n\r\nOverridden method should throw only same or sub class of the exception thrown by super class method.\r\n\r\nQuestions no -8 \r\nWhat is the output for the below code ?\r\n\r\nimport java.util.regex.Matcher;\r\nimport java.util.regex.Pattern;\r\n\r\npublic class Test {\r\n\t\r\n\tpublic static void main(String... args) {\r\n            \r\n\t\tPattern p = Pattern.compile(""a*b"");\r\n\t\tMatcher m = p.matcher(""b"");\r\n\t\tboolean b = m.matches();\r\n\t\tSystem.out.println(b);\r\n\r\n\t\t\r\n\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\noptions\r\nA)true\r\nB)Compile Error\r\nC)false\r\nD)b\r\n\r\nCorrect answer is : A\r\n\r\nExplanations : a*b means ""a"" may present zero or more time and ""b"" should be present once.\r\n\r\nQuestions no -9 \r\nWhat is the output for the below code ?\r\n\r\npublic class Test {\r\n\t\r\n\tpublic static void main(String... args) {\r\n            \r\n\t\t\r\n\t\tString input = ""1 fish 2 fish red fish blue fish"";\r\n\t\tScanner s = new Scanner(input).useDelimiter(""\\\\s*fish\\\\s*"");\r\n\t\tSystem.out.println(s.nextInt());\r\n\t\tSystem.out.println(s.nextInt());\r\n\t\tSystem.out.println(s.next());\r\n\t\tSystem.out.println(s.next());\r\n\t\ts.close(); \r\n\t\t\r\n\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\noptions\r\nA)1 2 red blue\r\nB)Compile Error - because Scanner is not defind in java.\r\nC)1 fish 2 fish red fish blue fish\r\nD)1 fish 2 fish red blue fish\r\n\r\nCorrect answer is : A\r\n\r\nExplanations : java.util.Scanner is a simple text scanner which can parse primitive types and strings using regular expressions.\r\n\r\nQuestions no -10 \r\nWhat is the output for the below code ?\r\n\r\npublic class Test {\r\n\t\r\n\tpublic static void main(String... args) {\r\n            \r\n\t\tPattern p = Pattern.compile(""a{3}b?c*"");\r\n\t\tMatcher m = p.matcher(""aaab"");\r\n\t\tboolean b = m.matches();\r\n\t\tSystem.out.println(b);\r\n\r\n\t\t\r\n\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\noptions\r\nA)true\r\nB)Compile Error \r\nC)false\r\nD)NullPointerException\r\n\r\nCorrect answer is : A\r\n\r\nExplanations :\r\nX?  X, once or not at all \r\nX*  X, zero or more times \r\nX+  X, one or more times \r\nX{n}  X, exactly n times \r\nX{n,}  X, at least n times \r\nX{n,m}  X, at least n but not more than m times\r\n\r\nQuestions no -11 \r\nWhat is the output for the below code ?\r\n\r\npublic class Test {\r\n\t\r\n\tpublic static void main(String... args) {\r\n            \r\n\t\tPattern p = Pattern.compile(""a{1,3}b?c*"");\r\n\t\tMatcher m = p.matcher(""aaab"");\r\n\t\tboolean b = m.matches();\r\n\t\tSystem.out.println(b);\r\n\r\n\t\t\r\n\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\noptions\r\nA)true\r\nB)Compile Error \r\nC)false\r\nD)NullPointerException\r\n\r\nCorrect answer is : A\r\n\r\nExplanations :\r\nX?  X, once or not at all \r\nX*  X, zero or more times \r\nX+  X, one or more times \r\nX{n}  X, exactly n times \r\nX{n,}  X, at least n times \r\nX{n,m}  X, at least n but not more than m times\r\n\r\nQuestions no -12 \r\nWhat is the output for the below code ?\r\n\r\npublic class A {\r\n\tpublic A() {\r\n        System.out.println(""A"");\r\n    }\r\n}\r\n\r\npublic class B extends A implements Serializable {\r\n\tpublic B() {\r\n        System.out.println(""B"");\r\n    }\r\n\r\n}\r\n\r\npublic class Test {\r\n\t\r\n\tpublic static void main(String... args) throws Exception {\r\n\t\tB b = new B();\r\n       \r\n        ObjectOutputStream save = new ObjectOutputStream(new FileOutputStream(""datafile""));\r\n        save.writeObject(b); \r\n        save.flush(); \r\n        \r\n\r\n        ObjectInputStream restore = new ObjectInputStream(new FileInputStream(""datafile""));\r\n        B z = (B) restore.readObject();\r\n\r\n        \r\n\r\n\t}\r\n\t\r\n}\r\n\r\n\r\n\r\n\r\noptions\r\nA)A B A\r\nB)A B A B\r\nC)B B\r\nD)A B\r\n\r\nCorrect answer is : A\r\n\r\nExplanations :On the time of deserialization , the Serializable object not create new object. So constructor of class B does not called.\r\n \r\nA is not Serializable object so constructor is called.\r\n\r\nQuestions no -13 \r\nWhat is the output for the below code ?\r\n\r\npublic class A {}\r\n\r\npublic class B implements Serializable  {\r\n\tA a = new A();\r\n\tpublic static void main(String... args){\r\n\t\tB b = new B();\r\n\t\ttry{\r\n\t\t\tFileOutputStream fs = new FileOutputStream(""b.ser"");\r\n\t\t\tObjectOutputStream os = new ObjectOutputStream(fs);\r\n\t\t\tos.writeObject(b);\r\n\t\t\tos.close();\r\n\t\t\t\r\n\t\t}catch(Exception e){\r\n\t\t\te.printStackTrace();\r\n\t\t}\r\n\t\t\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\n\r\noptions\r\nA)Compilation Fail\r\nB)java.io.NotSerializableException:  Because class A is not Serializable.\r\nC)Run properly\r\nD)Compilation Fail :  Because class A is not Serializable.\r\n\r\nCorrect answer is : B\r\n\r\nExplanations :It throws java.io.NotSerializableException:A  Because class A is not Serializable.\r\n\r\nWhen JVM tries to serialize object B it will try to serialize A also because (A a = new A()) is instance variable of Class B.\r\n\r\nSo thows NotSerializableException.\r\n\r\nQuestions no -14 \r\nWhat is the output for the below code running in the same JVM?\r\n\r\npublic class A implements Serializable {\r\n\ttransient int a = 7;\r\n\t  static int b = 9;\r\n\r\n}\r\n\r\npublic class B implements Serializable  {\r\n\t\r\n\tpublic static void main(String... args){\r\n\t\tA a = new A();\r\n\t\ttry {\r\n\t\t      ObjectOutputStream os = new ObjectOutputStream(\r\n\t\t         new FileOutputStream(""test.ser""));\r\n\t\t      os.writeObject(a);  \r\n\t\t      os. close();\r\n\t\t      System.out.print( + + a.b + "" "");\r\n\r\n\t\t      ObjectInputStream is = new ObjectInputStream(new FileInputStream(""test.ser""));\r\n\t\t      A s2 = (A)is.readObject();\r\n\t\t      is.close();\r\n\t\t      System.out.println(s2.a + "" "" + s2.b);\r\n\t\t    } catch (Exception x) \r\n\t\t    {\r\n\t\t    \tx.printStackTrace();\r\n\t\t    }\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\n\r\noptions\r\nA)9 0 9\r\nB)9 7 9\r\nC)0 0 0\r\nD)0 7 0\r\n\r\nCorrect answer is : A\r\n\r\nExplanations :transient variables are not serialized when an object is serialized.\r\n\r\nIn the case of static variable you can get the values in the same JVM. \r\n\r\nQuestions no -15 \r\nWhat is the output for the below code ?\r\n\r\npublic enum Test {\r\n\tBREAKFAST(7, 30), LUNCH(12, 15), DINNER(19, 45);\r\n\t\r\n\tprivate int hh;\r\n\r\n\tprivate int mm;\r\n\r\n\tTest(int hh, int mm) {\r\n\t\tassert (hh >= 0 && hh <= 23) : ""Illegal hour."";\r\n\t\tassert (mm >= 0 && mm <= 59) : ""Illegal mins."";\r\n\t\tthis.hh = hh;\r\n\t\tthis.mm = mm;\r\n\t}\r\n\r\n\tpublic int getHour() {\r\n\t\treturn hh;\r\n\t}\r\n\r\n\tpublic int getMins() {\r\n\t\treturn mm;\r\n\t}\r\n\t\r\n\tpublic static void main(String args[]){\r\n\t\tTest t =  new BREAKFAST;\r\n\t\tSystem.out.println(t.getHour() +"":""+t.getMins());\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\noptions\r\nA)7:30\r\nB)Compile Error - an enum cannot be instantiated using the new operator.\r\nC)12:50\r\nD)19:45\r\n\r\nCorrect answer is : B\r\n\r\nExplanations : As an enum cannot be instantiated using the new operator, the constructors cannot be called explicitly.\r\nYou have to do like \r\nTest t =  BREAKFAST;\r\n\r\nQuestions no -16 \r\nWhat is the output for the below code ?\r\n\r\npublic class Test {\r\n\tenum Day {\r\n\t\tMONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY\r\n\t}\r\n\tenum Month {\r\n\t\tJAN, FEB\r\n\t}\r\n\r\n\tpublic static void main(String[] args) {\r\n\r\n\t\tint[] freqArray = { 12, 34, 56, 23, 5, 13, 78 };\r\n\r\n\t\t// Create a Map of frequencies\r\n\t\tMap<Day, Integer> ordinaryMap = new HashMap<Day, Integer>();\r\n\t\tfor (Day day : Day.values()) {\r\n\t\t\tordinaryMap.put(day, freqArray[day.ordinal()]);\r\n\t\t}\r\n\t\t\r\n\r\n\t\t// Create an EnumMap of frequencies\r\n\t\tEnumMap<Day, Integer> frequencyEnumMap = new EnumMap<Day, Integer>(ordinaryMap);\r\n\r\n\t\t// Change some frequencies\r\n\t\tfrequencyEnumMap.put(null, 100);\r\n\t\t\r\n\t\tSystem.out.println(""Frequency EnumMap: "" + frequencyEnumMap);\r\n\r\n\t\t\r\n\t}\r\n\r\n}\r\n\r\n\r\noptions\r\nA)Frequency EnumMap: {MONDAY=12, TUESDAY=34, WEDNESDAY=56, THURSDAY=23, FRIDAY=5, SATURDAY=13, SUNDAY=78}\r\nB)Compile Error \r\nC)NullPointerException\r\nD)Frequency EnumMap: {MONDAY=100, TUESDAY=34, WEDNESDAY=56, THURSDAY=23, FRIDAY=5, SATURDAY=13, SUNDAY=123}\r\n\r\nCorrect answer is : C\r\n\r\nExplanations : The null reference as a key is NOT permitted.\r\n\r\nQuestions no -17 \r\npublic class EnumTypeDeclarations {\r\n\t\r\n\tpublic void foo() {\r\n\t\t\r\n\t\tenum SimpleMeal { \r\n\t\t\tBREAKFAST, LUNCH, DINNER \r\n\t\t}\r\n\t}\r\n}\r\n\r\nIs the above code Compile without error ?\r\n\r\n\r\noptions\r\nA)Compile without error\r\nB)Compile with error\r\nC)Compile without error but Runtime Exception\r\nD)Compile without error but Enum Exception\r\n\r\nCorrect answer is : B\r\n\r\nExplanations :\r\nAn enum declaration is a special kind of class declaration:\r\n\r\na) It can be declared at the top-level and as static enum declaration. \r\n\r\nb) It is implicitly static, i.e. no outer object is associated with an enum constant. \r\n\r\nc) It is implicitly final unless it contains constant-specific class bodies, but it can implement interfaces. \r\n\r\nd) It cannot be declared abstract unless each abstract method is overridden in the constant-specific class body of every enum constant. \r\n\r\ne) Local (inner) enum declaration is NOT OK! \r\n\r\nHere in\r\npublic void foo() {\r\n\t\t\r\n\t\tenum SimpleMeal { \r\n\t\t\tBREAKFAST, LUNCH, DINNER \r\n\t\t}\r\n\t}\r\n\r\nenum declaration is local within method so compile time error.\r\n\r\nQuestions no -18 \r\nWhat is the output for the below code ?\r\n\r\npublic enum Test {\r\n\tint t;\r\n\tBREAKFAST(7, 30), LUNCH(12, 15), DINNER(19, 45);\r\n\t\r\n\tprivate int hh;\r\n\r\n\tprivate int mm;\r\n\r\n\tTest(int hh, int mm) {\r\n\t\tassert (hh >= 0 && hh <= 23) : ""Illegal hour."";\r\n\t\tassert (mm >= 0 && mm <= 59) : ""Illegal mins."";\r\n\t\tthis.hh = hh;\r\n\t\tthis.mm = mm;\r\n\t}\r\n\r\n\tpublic int getHour() {\r\n\t\treturn hh;\r\n\t}\r\n\r\n\tpublic int getMins() {\r\n\t\treturn mm;\r\n\t}\r\n\t\r\n\tpublic static void main(String args[]){\r\n\t\tTest t =  BREAKFAST;\r\n\t\tSystem.out.println(t.getHour() +"":""+t.getMins());\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\noptions\r\nA)7:30\r\nB)Compile Error \r\nC)12:15\r\nD)19:45\r\n\r\nCorrect answer is : B\r\n\r\nExplanations : The enum constants must be declared before any other declarations in an enum type.\r\n\r\nIn this case compile error because of declaration int t; before enum declaration.\r\n\r\nQuestions no -19 \r\nWhat is the output for the below code ?\r\n\r\npublic class B extends Thread{\r\npublic static void main(String argv[]){\r\nB b = new B();\r\nb.run();\r\n} \r\npublic void start(){\r\nfor (int i = 0; i < 10; i++){\r\nSystem.out.println(""Value of i = "" + i); \r\n}  \r\n}\r\n}\r\n\r\n\r\n\r\n\r\noptions\r\nA)A compile time error indicating that no run method is defined for the Thread class\r\nB)A run time error indicating that no run method is defined for the Thread class\r\nC)Clean compile and at run time the values 0 to 9 are printed out\r\nD)Clean compile but no output at runtime\r\n\r\nCorrect answer is : D\r\n\r\nExplanations : This is a bit of a sneaky one as I have swapped around the names of the methods you need to define and call when running a thread.\r\n If the for loop were defined in a method called public void run() and the call in the main method had been to b.start() The list of values from 0 to 9 \r\nwould have been output.\r\n\r\nQuestions no -20 \r\n\r\nWhat is the output for the below code ?\r\n\r\npublic class Test extends Thread{\r\n\r\n    static String sName = ""good"";\r\n    public static void main(String argv[]){\r\n    \tTest t = new Test();\r\n    t.nameTest(sName);\r\n    System.out.println(sName);\r\n    \r\n    }\r\n    public void nameTest(String sName){\r\n            sName = sName + "" idea "";\r\n             start();\r\n    }\r\n    public void run(){\r\n    \r\n    for(int i=0;i  <  4; i++){\r\n            sName = sName + "" "" + i;\r\n            \r\n    }\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n\r\noptions\r\nA)good\r\nB)good idea\r\nC)good idea good idea\r\nD)good 0 good 0 1\r\n\r\nCorrect answer is : A\r\n\r\nExplanations : Change value in local methods wouldn’t change in global in case of String ( because String object is immutable).\r\n\r\nQuestions no -21 \r\nWhat is the output for the below code ?\r\n\r\npublic class Test{\r\n\tpublic static void main(String argv[]){\r\n\tTest1 pm1 = new Test1(""One"");\r\n\tpm1.run();\r\n\tTest1 pm2 = new Test1(""Two"");\r\n\tpm2.run();\r\n\r\n\t}\r\n}\r\n\r\nclass Test1 extends Thread{\r\nprivate String sTname="""";\r\nTest1(String s){\r\n\tsTname = s;\r\n\r\n}\r\npublic void run(){\r\n\tfor(int i =0; i < 2 ; i++){\r\n\t\ttry{\r\n\t\t sleep(1000);\r\n\t\t}catch(InterruptedException e){}\r\n\r\n\t\tyield();\r\n\t\tSystem.out.println(sTname);\r\n\t\t}\r\n\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\noptions\r\nA)Compile error\r\nB)One One Two Two\r\nC)One Two One Two\r\nD)One Two\r\n\r\nCorrect answer is : B\r\n\r\nExplanations : If you call the run method directly it just acts as any other method and does not return to the calling code until it has finished. executing\r\n\r\nQuestions no -22 \r\nWhat is the output for the below code ?\r\n\r\npublic class Test extends Thread{\r\n    public static void main(String argv[]){\r\n        Test  b = new Test();\r\n        b.start();\r\n    }\r\n    public void run(){      \r\n        System.out.println(""Running"");\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\noptions\r\nA)Compilation clean and run but no output\r\nB)Compilation and run with the output ""Running""\r\nC)Compile time error with complaint of no Thread import\r\nD)Compile time error with complaint of no access to Thread package\r\n\r\nCorrect answer is : B\r\n\r\nExplanations :\r\nThe Thread class is part of the core java.lang package and does not need any explicit import statement.\r\n\r\nQuestions no -23 \r\nWhat is the output for the below code ?\r\n\r\npublic class Tech {\r\n\t public void tech() {\r\n\t      System.out.println(""Tech"");\r\n\t   }\r\n\r\n}\r\n\r\n\r\npublic class Atech {\r\n\r\n\tTech a = new Tech() {\t      \r\n\t      public void tech() {\r\n\t         System.out.println(""anonymous tech"");\r\n\t      }\r\n\t   };\r\n\t   \r\n\t   public void dothis() {\r\n\t\t      a.tech();     \r\n\t\t      \r\n\t\t   }\r\n\r\npublic static void main(String... args){\r\n\tAtech atech = new Atech();\r\n\tatech.dothis();\r\n}\r\n\r\n\r\n\r\n\r\noptions\r\nA)anonymous tech\r\nB)Compile Error \r\nC)Tech\r\nD)anonymous tech Tech\r\n\r\nCorrect answer is : A\r\n\r\nExplanations : This is anonymous subclass of the specified class type.\r\n\r\nAnonymous inner class ( anonymous subclass ) overriden the Tech super class of tech() method.\r\n\r\nTherefore Subclass method will get called.\r\n\r\nQuestions no -24 \r\nWhat is the output for the below code ?\r\n\r\npublic class Outer {\r\n\t private String x = ""Outer variable"";\r\n\t   void doStuff() {\r\n\t     String z = ""local variable"";\r\n\t     class Inner {\r\n\t       public void seeOuter() {\r\n\t         System.out.println(""Outer x is "" + x);\r\n\t         System.out.println(""Local variable z is "" + z);  \r\n\t       } \r\n\t     }   \r\n\t   }  \r\n\t   \r\n\t  \r\n}\r\n\r\n\r\n\r\n\r\noptions\r\nA)Outer x is Outer variable.\r\nB)Compile Error \r\nC)Local variable z is local variable.\r\nD)Outer x is Outer variable Local variable z is local variable\r\n\r\nCorrect answer is : B\r\n\r\nExplanations : Cannot refer to a non-final variable z inside an inner class defined in a different method.\r\n\r\nQuestions no -25\r\n\r\nWhat is the output for the below code ?\r\n\r\npublic class Test {\r\n\t\r\n\tpublic static void main(String... args) {\r\n\t\tfor(int i = 2; i < 4; i++)\r\n  for(int j = 2; j < 4; j++)\r\n     assert i!=j : i; \r\n\r\n\r\n\t}\r\n}\r\n\r\noptions\r\nA)The class compiles and runs, but does not print anything.\r\nB)The number 2 gets printed with AssertionError\r\nC)The number 3 gets printed with AssertionError\r\nD)compile error\r\n\r\nCorrect answer is : B\r\n\r\nExplanations : When i and j are both 2, assert condition is false, and AssertionError gets generated. \r\n\r\nQuestions no -26\r\n\r\nWhat is the output for the below code ?\r\n\r\npublic class Test {\r\n\t\r\n\tpublic static void main(String... args) {\r\n\t\tfor(int i = 2; i < 4; i++)\r\n  for(int j = 2; j < 4; j++)\r\n\tif(i < j)\r\n     assert i!=j : i; \r\n\r\n\r\n\t}\r\n}\r\n\r\noptions\r\nA)The class compiles and runs, but does not print anything.\r\nB)The number 2 gets printed with AssertionError\r\nC)The number 3 gets printed with AssertionError\r\nD)compile error\r\n\r\nCorrect answer is : A\r\n\r\nExplanations : When if condition returns true, the assert statement also returns true.\r\nHence AssertionError not generated.\r\n\r\nQuestions no -26 \r\nWhat is the output for the below code ?\r\n\r\npublic class NameBean {\r\n\tprivate String str;\r\n\t\r\n\tNameBean(String str ){\r\n\t\tthis.str = str;\r\n\t}\r\n\t\r\n\tpublic String toString() {\r\n\t\treturn str;\r\n\t}\r\n}\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\r\nimport java.util.HashSet;\r\n\r\npublic class CollClient {\r\n\t\r\n\tpublic static void main(String ... sss) {\r\n\t\tHashSet myMap = new HashSet();\r\n\t\tString s1 = new String(""das"");\r\n\t\tString s2 = new String(""das"");\r\n\tNameBean s3 = new NameBean(""abcdef"");\r\n\tNameBean s4 = new NameBean(""abcdef"");\r\n\t\t\r\n\t\tmyMap.add(s1);\r\n\t\tmyMap.add(s2);\r\n\t\tmyMap.add(s3);\r\n\t\tmyMap.add(s4);\r\n\t\t\r\n\t\tSystem.out.println(myMap);\r\n\t}\t\r\n}\r\n\r\n\r\n\r\n\r\noptions\r\nA)das abcdef abcdef\r\nB)das das abcdef abcdef\r\nC)das abcdef\r\nD)abcdef abcdef\r\n\r\nCorrect answer is : A\r\n\r\nExplanations : Need to implement 'equals' and 'hashCode' methods to get unique Set for user defind objects(NameBean).\r\n\r\nString object internally implements 'equals' and 'hashCode' methods therefore Set only stored one value.\r\n\r\nQuestions no -27 \r\nSynchronized resizable-array implementation of the List interface is _____________?\r\n\r\n\r\n\r\n\r\noptions\r\nA)Vector\r\nB)ArrayList\r\nC)Hashtable\r\nD)HashMap\r\n\r\nCorrect answer is : A\r\n\r\nExplanations : Vector implements List, RandomAccess - Synchronized resizable-array implementation of the List interface with additional ""legacy methods.""\r\n\r\nQuestions no -28 \r\nWhat is the output for the below code ?\r\npublic class Test {\r\n\r\n    \r\n    public static void main(String argv[]){\r\n    \t \r\n    \tArrayList list = new ArrayList(); \r\n    \tArrayList<String> listStr = list; \r\n    \tArrayList<StringBuffer> listBuf = list; \r\n    \tlistStr.add(0, ""Hello""); \r\n    \tStringBuffer buff = listBuf.get(0); \r\n       System.out.println(buff.toString());\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n\r\noptions\r\nA)Hello\r\nB)Compile error\r\nC)java.lang.ClassCastException\r\nD)null\r\n\r\nCorrect answer is : C\r\n\r\nExplanations : java.lang.String cannot be cast to java.lang.StringBuffer at the code StringBuffer buff = listBuf.get(0); \r\nSo thows java.lang.ClassCastException.\r\n\r\nQuestions no -29 \r\nWhat is the output for the below code ?\r\n\r\nimport java.util.LinkedList;\r\nimport java.util.Queue;\r\n\r\n\r\npublic class Test {\r\n\tpublic static void main(String... args) {\r\n        \r\n\t\t\r\n\t\t\r\n\t\tQueue<String> q = new LinkedList<String>();\r\n\t\t        q.add(""newyork"");\r\n\t\t        q.add(""ca"");\r\n\t\t        q.add(""texas"");\r\n\t\t        show(q);\r\n\t\t    }\r\n\t\t\r\n\t\t    public static void show(Queue q) {\r\n\t\t        q.add(new Integer(11));\r\n\t\t        while (!q.isEmpty ( ) )\r\n\t\t            System.out.print(q.poll() + ""  "");\r\n\t\t    }\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\noptions\r\nA)Compile error : Integer can't add\r\nB)newyork  ca  texas  11\r\nC)newyork  ca  texas\r\nD)newyork  ca \r\n\r\nCorrect answer is : B\r\n\r\nExplanations : \r\nq was originally declared as Queue<String>, But in show() method it is passed as an untyped Queue. nothing in the compiler or JVM prevents us from adding an Integer after that.\r\nIf the show method signature is public static void show(Queue<String> q) than you can't add Integer, Only String allowed. But public static void show(Queue q) is untyped Queue so you can add Integer.\r\npoll() Retrieves and removes the head of this queue, or returns null if this queue is empty.\r\n\r\nQuestions no -30 \r\nWhat is the output for the below code ?\r\n\r\npublic interface TestInf {\r\n int i =10;\r\n}\r\n\r\npublic class Test {\r\n\tpublic static void main(String... args) {\r\n\t\tTestInf.i=12;\r\n\t\tSystem.out.println(TestInf.i);\r\n\t\r\n\t}\r\n\t\r\n\t\r\n\t\r\n}\r\n\r\n\r\n\r\noptions\r\nA)Compile with error\r\nB)10\r\nC)12\r\nD) Runtime Exception\r\n\r\nCorrect answer is : A\r\n\r\nExplanations : All the variables declared in interface is Implicitly static and final , therefore can't change the value.\r\n\r\nQuestions no -31 \r\nWhat is the output for the below code ?\r\n\r\npublic class Test {\r\n            static { int a = 5; }\r\n            public static void main(String[] args){\r\n            System.out.println(a);\r\n            }\r\n          }\r\n\r\n\r\n\r\noptions\r\nA)Compile with error\r\nB)5\r\nC)0\r\nD) Runtime Exception\r\n\r\nCorrect answer is : A\r\n\r\nExplanations : A variable declared  in a static initialiser is not accessible outside its enclosing block.\r\n\r\nQuestions no -32 \r\nWhat is the output for the below code ?\r\n\r\nclass A {\r\n  { System.out.print(""b1 ""); }\r\n  public A() { System.out.print(""b2 ""); }\r\n}\r\nclass B extends A {\r\n  static { System.out.print(""r1 ""); }\r\n  public B() { System.out.print(""r2 ""); }\r\n  { System.out.print(""r3 ""); }\r\n  static { System.out.print(""r4 ""); }\r\n}\r\nclass C extends B {\r\n  public static void main(String[] args) {\r\n    System.out.print(""pre "");\r\n    new C();\r\n    System.out.println(""post "");\r\n  }\r\n}\r\n\r\n\r\n\r\noptions\r\nA)r1 r4 pre b1 b2 r3 r2 post\r\nB)r1 r4 pre b1 b2  post\r\nC)r1 r4 pre b1 b2  post r3 r2\r\nD)pre r1 r4  b1 b2  r2 r3 post\r\n\r\nCorrect answer is : A\r\n\r\nExplanations : All static blocks execute first then blocks and constructor. \r\n\r\nBlocks and constructor executes (super class block then super class constructor, sub class block then sub class constructor).\r\n\r\nSequence for static blocks is super class first then sub class.\r\n\r\nSequence for blocks is super class first then sub class.\r\n\r\n\r\nQuestions no -33 \r\nWhat is the output for the below code ?\r\n\r\npublic class Test {\r\n\t\r\n\tpublic static void main(String... args) throws Exception {\r\n\t\tInteger i = 34;\r\n\t\tint l = 34;\r\n\t\tif(i.equals(l)){\r\n\t\t\tSystem.out.println(true);\r\n\t\t}else{\r\n\t\t\tSystem.out.println(false);\r\n\t\t}\r\n\r\n\t}\r\n\t\r\n}\r\n\r\n\r\n\r\noptions\r\nA)true\r\nB)false\r\nC)Compile Error\r\nD) Runtime Exception\r\n\r\nCorrect answer is : A\r\n\r\nExplanations : equals() method for the integer wrappers will only return true if the two primitive types and the two values are equal.\r\n\r\nQuestions no -34 \r\nWhich statement is true about outer class?\r\n\r\n\r\n\r\noptions\r\nA)outer class can only declare public , abstract and final\r\nB)outer class may be private\r\nC)outer class can't be abstract\r\nD)outer class can be static\r\n\r\nCorrect answer is : A\r\n\r\nExplanations : outer class can only declare public , abstract and final.\r\n\r\nQuestions no -35 \r\n\r\nWhat is the output for the below code ?\r\n\r\nstatic public class Test {\r\n\tpublic static void main(String[] args) {\r\n\t\t  char c = 'a';\r\n\t\r\n\t\t switch(c){\r\n\t\t     case 65:\r\n\t\t              System.out.println(""one"");break;\r\n\t\t     case 'a':\r\n\t\t              System.out.println(""two"");break;\r\n\t\t     case 3:\r\n\t\t              System.out.println(""three"");\r\n\t\t}\r\n\t\t\r\n\t\t}\r\n\t\r\n\r\n}\r\n\r\n\r\n\r\noptions\r\nA)one\r\nB)two\r\nC)Compile error - char can't be permitted in switch statement \r\nD)Compile error - Illegal modifier for the class Test; only public, abstract & final are permitted.\r\n\r\n\r\nCorrect answer is : D\r\n\r\nExplanations : outer class can only declare public , abstract and final.\r\nIllegal modifier for the class Test; only public, abstract & final are permitted\r\n\r\nQuestions no -36\r\n\r\nWhat is the output for the below code ?\r\n\r\npublic class Test {\r\n\t\r\n\tpublic static void main(String... args) {\r\n\t\tArrayList<Integer> list = new ArrayList<Integer>();\r\n\t\tlist.add(1);\r\n\t\tlist.add(2);\r\n\t\tlist.add(3);\r\n\t\t\r\n\t\tfor(int i:list)\r\n\t\t\tSystem.out.println(i);\r\n\t\t\r\n\r\n\t}\r\n}\r\n\r\noptions\r\nA)1 2 3\r\nB)Compile error , can't add primitive type in ArrayList\r\nC)Compile error on for(int i:list) , Incorrect Syntax\r\nD)0 0 0\r\n\r\nCorrect answer is : A\r\n\r\nExplanations : JDK 1.5, 1.6 allows add primitive type in ArrayList  and for(int i:list) syntax is also correct.\r\nfor(int i:list) is same as \r\nfor(int i=0; i < list.size();i++){\r\n\t\t\tint a = list.get(i);\r\n\t\t\t\r\n\t\t}\r\n\r\nQuestions no -37 \r\nWhat is the output for the below code ?\r\n\r\npublic class SuperClass {\r\n\tpublic int doIt(String str, Integer... data)throws ArrayIndexOutOfBoundsException{\r\n\t\tString signature = ""(String, Integer[])"";\r\n\t\tSystem.out.println(str + ""  "" + signature);\r\n\t\treturn 1;\r\n\t}\r\n\r\n}\r\n\r\n\r\npublic class SubClass extends SuperClass{\r\n\r\n\tpublic int doIt(String str, Integer... data) throws Exception\r\n\t{\r\n\t\tString signature = ""(String, Integer[])"";\r\n\t\tSystem.out.println(""Overridden: "" + str + "" "" + signature);\r\n\t\treturn 0;\r\n\t}\r\n\t\r\n\tpublic static void main(String... args)\r\n\t{\r\n\t\tSuperClass sb = new SubClass();\r\n\t\ttry{\r\n\t\t\tsb.doIt(""hello"", 3);\r\n\t\t}catch(Exception e){\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t}\r\n\t\r\n}\r\n\r\n\r\n\r\noptions\r\nA)Overridden: hello (String, Integer[])\r\nB)hello (String, Integer[])\r\nC)This code throws an Exception at Runtime\r\nD)Compile with error\r\n\r\nCorrect answer is : D\r\n\r\nExplanations : Exception Exception is not compatible with throws clause in SuperClass.doIt(String, Integer[]). \r\nThe same exception or subclass of that exception is allowed.\r\n\r\nQuestions no -38\r\nWhat is the result of executing the following code, using the parameters 0 and 3 ?\r\n\r\npublic void divide(int a, int b) {\r\n\ttry {\r\n\t\tint c = a / b;\r\n\t} catch (Exception e) {\r\n\t\tSystem.out.print(""Exception "");\r\n\t} finally {\r\n\t\tSystem.out.println(""Finally"");\r\n}\r\n\r\n\r\n\r\noptions\r\nA)Prints out: Exception Finally\r\nB)Prints out: Finally\r\nC)Prints out: Exception\r\nD)Compile with error\r\n\r\nCorrect answer is : B\r\n\r\nExplanations : finally block always executed whether exception occurs or not. \r\n\t0/3 = 0 Does not throws exception.\r\n\r\nQuestions no -39\r\nWhich of the below statement is true about Error?\r\n\r\n\r\n\r\noptions\r\nA)An Error is a subclass of Throwable\r\nB)An Error is a subclass of Exception\r\nC)Error indicates serious problems that a reasonable application should not try to catch.\r\nD)An Error is a subclass of IOException\r\n\r\nCorrect answer is : A and C\r\n\r\nExplanations : An Error is a subclass of Throwable that indicates serious problems that a reasonable application should not try to catch.\r\n\r\nQuestions no -40\r\nWhich of the following is type of RuntimeException?\r\n\r\n\r\n\r\n\r\n\r\noptions\r\nA)IOException\r\nB)ArrayIndexOutOfBoundsException\r\nC)Exception\r\nD)Error\r\n\r\nCorrect answer is : B\r\n\r\nExplanations : Below is the tree.\r\njava.lang.Object\r\n  java.lang.Throwable\r\n      java.lang.Exception\r\n          java.lang.RuntimeException\r\n              java.lang.IndexOutOfBoundsException\r\n                  java.lang.ArrayIndexOutOfBoundsException\r\n\r\nQuestions no -41 \r\nWhat is the output for the below code ?\r\n\r\npublic class Test {\r\n\t\r\n\tpublic static void main(String... args) throws Exception {\r\n\t\t File file = new File(""test.txt"");  \r\n\t\t System.out.println(file.exists());\r\n\t\t FileWriter fw = new FileWriter(file); \r\n\t\t System.out.println(file.exists());\r\n\t}\r\n\t\r\n}\r\n\r\n\r\n\r\n\r\noptions\r\nA)true true\r\nB)false false\r\nC)false true\r\nD)true false\r\n\r\nCorrect answer is : C\r\n\r\nExplanations :Creating a new instance of the class File, you're not yet making an actual file, you're just creating a filename.\r\n\r\nSo file.exists() return false.\r\n\r\nFileWriter fw = new FileWriter(file) do three things:\r\n\r\nIt created a FileWriter reference variable fw.\r\n\r\nIt created a FileWriter object, and assigned it to fw.\r\n\r\nIt created an actual empty file out on the disk.\r\n\r\nSo file.exists() return true.\r\n\r\nQuestions no -42 \r\nWhen comparing java.io.BufferedWriter and java.io.FileWriter, which capability exist as a method in only one of two ?\r\n\r\n\r\n\r\n\r\noptions\r\nA)closing the stream\r\nB)flushing the stream\r\nC)writting to the stream\r\nD)writting a line separator to the stream\r\n\r\nCorrect answer is : D\r\n\r\nExplanations :A newLine() method is provided in BufferedWriter which is not in FileWriter.\r\n\r\nQuestions no -43 \r\nWhat is the output for the below code ?\r\npublic class Test{\r\n\r\npublic static void main(String[] args) {\r\n  int i1=1;\r\n switch(i1){\r\n     case 1:\r\n              System.out.println(""one"");\r\n     case 2:\r\n              System.out.println(""two"");\r\n     case 3:\r\n              System.out.println(""three"");\r\n}\r\n}\r\n}\r\n\r\n\r\noptions\r\nA)one two three\r\nB)one\r\nC)one two\r\nD)Compile error.\r\n\r\nCorrect answer is : A\r\n\r\nExplanations : There is no break statement in case 1 so it causes the below case statements to execute regardless of their values.\r\n\r\nQuestions no -44 \r\nWhat is the output for the below code ?\r\npublic class Test {\r\n\tpublic static void main(String[] args) {\r\n\t\t  char c = 'a';\r\n\t\r\n\t\t switch(c){\r\n\t\t     case 65:\r\n\t\t              System.out.println(""one"");break;\r\n\t\t     case 'a':\r\n\t\t              System.out.println(""two"");break;\r\n\t\t     case 3:\r\n\t\t              System.out.println(""three"");\r\n\t\t}\r\n\t\t\r\n\t\t}\r\n\t\r\n\r\n}\r\n\r\n\r\noptions\r\nA)one two three\r\nB)one\r\nC)two\r\nD)Compile error - char can't be in switch statement.\r\n\r\nCorrect answer is : C\r\n\r\nExplanations : Compile properly and print two.\r\n\r\nQuestions no -45 \r\nWhat is the output for the below code ?\r\n\r\nimport java.util.NavigableMap;\r\nimport java.util.concurrent.ConcurrentSkipListMap;\r\n\r\n\r\npublic class Test {\r\n\tpublic static void main(String... args) {\r\n        \r\n\t\t\r\n\t\tNavigableMap <Integer, String>navMap = new \r\n        ConcurrentSkipListMap<Integer, String>();\r\n\t\t\r\n\t\tnavMap.put(4, ""April"");\r\n\t\tnavMap.put(5, ""May"");\r\n\t\tnavMap.put(6, ""June"");\r\n\t\tnavMap.put(1, ""January"");\r\n\t\tnavMap.put(2, ""February"");\r\n\t\tnavMap.put(3, ""March"");\r\n\r\n        navMap.pollFirstEntry();\r\n        navMap.pollLastEntry();\r\n        navMap.pollFirstEntry();\r\n        System.out.println(navMap.size());\r\n\r\n\r\n\t     \t      \r\n\t}\r\n}\r\n----------------------------------- SOURCE END -------------------------------------",1419754026623
error,log,,,"Problems occurred when invoking code from plug-in: ""org.eclipse.jdt.ui"".",1419754026626
error,log,,,"Error in JDT Core during AST creation",1419754026630
error,log,,,"Exception occurred during compilation unit conversion:\r\n----------------------------------- SOURCE BEGIN -------------------------------------\r\n\r\n\t\r\nOCPJP 6 Free Mock Exam Practice Questions\r\n\r\n\r\nAre you prepared for OCPJP6 1Z0-851 exam , check your mock score ?\r\nOCPJP6 Practice Test 1Z0-851\r\n\r\nQuestions no -1 \r\nWhat is the output for the below code ?\r\n\r\nclass A implements Runnable{\r\n\tpublic void run(){\r\n\t\tSystem.out.println(Thread.currentThread().getName());\r\n\t}   \r\n}\r\n\r\n\r\npublic class Test {\t\t\r\n\tpublic static void main(String... args) {\t\r\n\t\tA a = new A();\r\n\t\tThread t = new Thread(a);\r\n\t\tThread t1 = new Thread(a);\t\t\r\n\t\tt.setName(""t"");\r\n\t\tt1.setName(""t1"");\r\n\t\tt.setPriority(10);\r\n\t\tt1.setPriority(-3);\r\n\t\tt.start();\r\n\t\tt1.start();\r\n\t\t\r\n\t}\r\n}\r\n\r\n\r\n\r\nOptions are\r\n\r\nA.t t1\r\nB.t1 t\r\nC.t t\r\nD.Compilation succeed but Runtime Exception\r\n\r\nAnswer :\r\nD is the correct answer.\r\n\r\nThread priorities are set using a positive integer, usually between 1 and 10. t1.setPriority(-3); throws java.lang.IllegalArgumentException.\r\n\r\n\r\n\r\nQuestions no -2 \r\nWhat is the output for the below code ?\r\n\r\nclass A implements Runnable{\r\n\tpublic void run(){\r\n\t\tSystem.out.println(Thread.currentThread().getName());\r\n\t}   \r\n}\r\n\r\n1. public class Test {\t\t\r\n2.\tpublic static void main(String... args) {\t\r\n3.\t\tA a = new A();\r\n4.\t\tThread t = new Thread(a);\r\n5.\t\tt.setName(""good"");\r\n6.\t\tt.start();\r\n7.\t}\r\n8. }\r\n\r\n\r\n\r\n\r\nOptions are\r\n\r\nA.good\r\nB.null\r\nC.Compilation fails with an error at line 5\r\nD.Compilation succeed but Runtime Exception\r\n\r\nAnswer :\r\nA is the correct answer.\r\n\r\nThread.currentThread().getName() return name of the current thread.\r\n\r\n\r\nQuestions no -3 \r\nWhat is the output for the below code ?\r\n\r\npublic class Test {\r\n\t\r\n\r\n\tpublic static void main(String[] args) {\r\n\t\tBoolean expr = true;\r\n\t\tif (expr) {\r\n\t\t\tSystem.out.println(""true"");\r\n\t\t} else {\r\n\t\t\tSystem.out.println(""false"");\r\n\t\t}\r\n\t\t\r\n\t}\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\noptions\r\nA)true\r\nB)Compile Error - can't use Boolean object in if().\r\nC)false\r\nD)Compile Properly but Runtime Exception.\r\n\r\nCorrect answer is : A\r\n\r\nExplanations : In the if statement, condition can be Boolean object in jdk1.5 and jdk1.6.\r\nIn the previous version only boolean is allowed.\r\n\r\nQuestions no -4 \r\nWhat is the output for the below code ?\r\n\r\npublic class Test {\r\n\t\r\n\r\n\tpublic static void main(String[] args) {\r\n\t\tList<Integer> list = new ArrayList<Integer>(); \r\n\t\tlist.add(0, 59);\r\n\t\tint total = list.get(0);\r\n\t\tSystem.out.println(total);\r\n\r\n\t\t\r\n\t}\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\noptions\r\nA)59\r\nB)Compile time error, because you have to do int total = ((Integer)(list.get(0))).intValue();\r\nC)Compile time error, because can't add primitive type in List.\r\nD)Compile Properly but Runtime Exception.\r\n\r\nCorrect answer is : A\r\n\r\nExplanations :Manual conversion between primitive types (such as an int) and wrapper classes \r\n\r\n(such as Integer) is necessary when adding a primitive data type to a collection in jdk1.4 but\r\n\r\nThe new autoboxing/unboxing feature eliminates this manual conversion in jdk 1.5 and jdk 1.6.\r\n\r\nQuestions no -3 \r\nWhat is the output for the below code ?\r\n\r\npublic class Test {\r\n\t\r\n\r\n\tpublic static void main(String[] args) {\r\n\t\tInteger i = null;\r\n\t\tint j = i;\r\n\t\tSystem.out.println(j);\r\n\t\t\r\n\t}\r\n\r\n\r\n}\r\n\r\n\r\n\r\noptions\r\nA)0\r\nB)Compile with error \r\nC)null\r\nD)NullPointerException\r\n\r\nCorrect answer is : D\r\n\r\nExplanations :An Integer expression can have a null value. If your program tries to autounbox null,\r\n it will throw a NullPointerException.\r\n\r\nQuestions no -4 \r\nWhat is the output for the below code ?\r\n\r\npublic class Outer {\r\n\tprivate int a = 7;\r\n\t   \r\n\t   class Inner {\r\n\t      public void displayValue() {\r\n\t         System.out.println(""Value of a is "" + a);\r\n\t      }\r\n\t   }\r\n\t}\r\n\r\n\r\npublic class Test {\r\n\t\r\n\tpublic static void main(String... args) throws Exception {\r\n\t\tOuter mo = new Outer();     \r\n\t\t  Outer.Inner inner = mo.new Inner();\r\n\t\t  inner.displayValue();\r\n\r\n\t}\r\n\t\r\n}\r\n\r\n\r\n\r\n\r\noptions\r\nA)Value of a is 7\r\nB)Compile Error - not able to access private member.\r\nC)Runtime Exception\r\nD)Value of a is 8\r\n\r\nCorrect answer is : A\r\n\r\nExplanations : An inner class instance can never stand alone without a direct relationship to an instance of the outer class.\r\n\r\nyou can access the inner class is through a live instance of the outer class.\r\n\r\nInner class can access private member of the outer class.\r\n\r\nQuestions no -5 \r\nWhat is the output for the below code ?\r\n\r\npublic class B {\r\n\t\r\n\tpublic String getCountryName(){\r\n\t\treturn ""USA"";\r\n\t}\r\n\t\r\n\tpublic StringBuffer getCountryName(){\r\n\t\tStringBuffer sb = new StringBuffer();\r\n\t\tsb.append(""UK"");\r\n\t\treturn sb;\r\n\t}\r\n\t\r\n\t\r\n\tpublic static void main(String[] args){\r\n\t\tB b = new B();\r\n\t\tSystem.out.println(b.getCountryName().toString());\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\noptions\r\nA)Compile with error\r\nB)USA\r\nC)UK\r\nD) Runtime Exception\r\n\r\nCorrect answer is : A\r\n\r\nExplanations : You cannot have two methods in the same class with signatures that only differ by return type.\r\n\r\nQuestions no -6\r\nWhat is the output for the below code ?\r\n\r\npublic class C {\r\n\r\n}\r\n\r\npublic class D extends C{\r\n\r\n}\r\n\r\npublic class A {\r\n\t\r\n\tpublic C getOBJ(){\r\n\t\tSystem.out.println(""class A - return C"");\r\n\t\treturn new C();\r\n\t\t\r\n\t}\r\n\r\n}\r\n\r\npublic class B extends A{\r\n\t\r\n\tpublic D getOBJ(){\r\n\t\tSystem.out.println(""class B - return D"");\r\n\t\treturn new D();\r\n\t\t\r\n\t}\r\n\r\n}\r\n\r\npublic class Test {\r\n\r\npublic static void main(String... args) {\r\n     A a = new B();\r\n     a.getOBJ();\r\n\t\r\n     }\r\n}\r\n\r\n\r\n\r\noptions\r\nA)Compile with error - Not allowed to override the return type of a method with a subtype of the original type.\r\nB)class A - return C\r\nC)class B - return D\r\nD) Runtime Exception\r\n\r\nCorrect answer is : C\r\n\r\nExplanations : From J2SE 5.0 onwards. You are now allowed to override the return type of a method with a subtype of the original type.\r\n\r\nQuestions no -7\r\nWhat is the output for the below code ?\r\n\r\npublic class A {\r\n\t\r\n\tpublic String getName() throws ArrayIndexOutOfBoundsException{\r\n\t\treturn ""Name-A"";\r\n\t}\r\n\t\r\n}\r\n\t\r\npublic class C extends A{\r\n\t\r\n\tpublic String getName() throws Exception{\r\n\t\treturn ""Name-C"";\r\n\t}\r\n\r\n}\r\n\t\r\n\t\r\npublic class Test {\r\n\tpublic static void main(String... args) {\r\n\t\tA a = new C();\r\n\t\ta.getName();\r\n\t}\r\n\t\r\n}\r\n\r\n\r\n\r\noptions\r\nA)Compile with error\r\nB)Name-A\r\nC)Name-C\r\nD)Runtime Exception\r\n\r\nCorrect answer is : A\r\n\r\nExplanations : Exception Exception is not compatible with throws clause in A.getName().\r\n\r\nOverridden method should throw only same or sub class of the exception thrown by super class method.\r\n\r\nQuestions no -8 \r\nWhat is the output for the below code ?\r\n\r\nimport java.util.regex.Matcher;\r\nimport java.util.regex.Pattern;\r\n\r\npublic class Test {\r\n\t\r\n\tpublic static void main(String... args) {\r\n            \r\n\t\tPattern p = Pattern.compile(""a*b"");\r\n\t\tMatcher m = p.matcher(""b"");\r\n\t\tboolean b = m.matches();\r\n\t\tSystem.out.println(b);\r\n\r\n\t\t\r\n\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\noptions\r\nA)true\r\nB)Compile Error\r\nC)false\r\nD)b\r\n\r\nCorrect answer is : A\r\n\r\nExplanations : a*b means ""a"" may present zero or more time and ""b"" should be present once.\r\n\r\nQuestions no -9 \r\nWhat is the output for the below code ?\r\n\r\npublic class Test {\r\n\t\r\n\tpublic static void main(String... args) {\r\n            \r\n\t\t\r\n\t\tString input = ""1 fish 2 fish red fish blue fish"";\r\n\t\tScanner s = new Scanner(input).useDelimiter(""\\\\s*fish\\\\s*"");\r\n\t\tSystem.out.println(s.nextInt());\r\n\t\tSystem.out.println(s.nextInt());\r\n\t\tSystem.out.println(s.next());\r\n\t\tSystem.out.println(s.next());\r\n\t\ts.close(); \r\n\t\t\r\n\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\noptions\r\nA)1 2 red blue\r\nB)Compile Error - because Scanner is not defind in java.\r\nC)1 fish 2 fish red fish blue fish\r\nD)1 fish 2 fish red blue fish\r\n\r\nCorrect answer is : A\r\n\r\nExplanations : java.util.Scanner is a simple text scanner which can parse primitive types and strings using regular expressions.\r\n\r\nQuestions no -10 \r\nWhat is the output for the below code ?\r\n\r\npublic class Test {\r\n\t\r\n\tpublic static void main(String... args) {\r\n            \r\n\t\tPattern p = Pattern.compile(""a{3}b?c*"");\r\n\t\tMatcher m = p.matcher(""aaab"");\r\n\t\tboolean b = m.matches();\r\n\t\tSystem.out.println(b);\r\n\r\n\t\t\r\n\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\noptions\r\nA)true\r\nB)Compile Error \r\nC)false\r\nD)NullPointerException\r\n\r\nCorrect answer is : A\r\n\r\nExplanations :\r\nX?  X, once or not at all \r\nX*  X, zero or more times \r\nX+  X, one or more times \r\nX{n}  X, exactly n times \r\nX{n,}  X, at least n times \r\nX{n,m}  X, at least n but not more than m times\r\n\r\nQuestions no -11 \r\nWhat is the output for the below code ?\r\n\r\npublic class Test {\r\n\t\r\n\tpublic static void main(String... args) {\r\n            \r\n\t\tPattern p = Pattern.compile(""a{1,3}b?c*"");\r\n\t\tMatcher m = p.matcher(""aaab"");\r\n\t\tboolean b = m.matches();\r\n\t\tSystem.out.println(b);\r\n\r\n\t\t\r\n\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\noptions\r\nA)true\r\nB)Compile Error \r\nC)false\r\nD)NullPointerException\r\n\r\nCorrect answer is : A\r\n\r\nExplanations :\r\nX?  X, once or not at all \r\nX*  X, zero or more times \r\nX+  X, one or more times \r\nX{n}  X, exactly n times \r\nX{n,}  X, at least n times \r\nX{n,m}  X, at least n but not more than m times\r\n\r\nQuestions no -12 \r\nWhat is the output for the below code ?\r\n\r\npublic class A {\r\n\tpublic A() {\r\n        System.out.println(""A"");\r\n    }\r\n}\r\n\r\npublic class B extends A implements Serializable {\r\n\tpublic B() {\r\n        System.out.println(""B"");\r\n    }\r\n\r\n}\r\n\r\npublic class Test {\r\n\t\r\n\tpublic static void main(String... args) throws Exception {\r\n\t\tB b = new B();\r\n       \r\n        ObjectOutputStream save = new ObjectOutputStream(new FileOutputStream(""datafile""));\r\n        save.writeObject(b); \r\n        save.flush(); \r\n        \r\n\r\n        ObjectInputStream restore = new ObjectInputStream(new FileInputStream(""datafile""));\r\n        B z = (B) restore.readObject();\r\n\r\n        \r\n\r\n\t}\r\n\t\r\n}\r\n\r\n\r\n\r\n\r\noptions\r\nA)A B A\r\nB)A B A B\r\nC)B B\r\nD)A B\r\n\r\nCorrect answer is : A\r\n\r\nExplanations :On the time of deserialization , the Serializable object not create new object. So constructor of class B does not called.\r\n \r\nA is not Serializable object so constructor is called.\r\n\r\nQuestions no -13 \r\nWhat is the output for the below code ?\r\n\r\npublic class A {}\r\n\r\npublic class B implements Serializable  {\r\n\tA a = new A();\r\n\tpublic static void main(String... args){\r\n\t\tB b = new B();\r\n\t\ttry{\r\n\t\t\tFileOutputStream fs = new FileOutputStream(""b.ser"");\r\n\t\t\tObjectOutputStream os = new ObjectOutputStream(fs);\r\n\t\t\tos.writeObject(b);\r\n\t\t\tos.close();\r\n\t\t\t\r\n\t\t}catch(Exception e){\r\n\t\t\te.printStackTrace();\r\n\t\t}\r\n\t\t\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\n\r\noptions\r\nA)Compilation Fail\r\nB)java.io.NotSerializableException:  Because class A is not Serializable.\r\nC)Run properly\r\nD)Compilation Fail :  Because class A is not Serializable.\r\n\r\nCorrect answer is : B\r\n\r\nExplanations :It throws java.io.NotSerializableException:A  Because class A is not Serializable.\r\n\r\nWhen JVM tries to serialize object B it will try to serialize A also because (A a = new A()) is instance variable of Class B.\r\n\r\nSo thows NotSerializableException.\r\n\r\nQuestions no -14 \r\nWhat is the output for the below code running in the same JVM?\r\n\r\npublic class A implements Serializable {\r\n\ttransient int a = 7;\r\n\t  static int b = 9;\r\n\r\n}\r\n\r\npublic class B implements Serializable  {\r\n\t\r\n\tpublic static void main(String... args){\r\n\t\tA a = new A();\r\n\t\ttry {\r\n\t\t      ObjectOutputStream os = new ObjectOutputStream(\r\n\t\t         new FileOutputStream(""test.ser""));\r\n\t\t      os.writeObject(a);  \r\n\t\t      os. close();\r\n\t\t      System.out.print( + + a.b + "" "");\r\n\r\n\t\t      ObjectInputStream is = new ObjectInputStream(new FileInputStream(""test.ser""));\r\n\t\t      A s2 = (A)is.readObject();\r\n\t\t      is.close();\r\n\t\t      System.out.println(s2.a + "" "" + s2.b);\r\n\t\t    } catch (Exception x) \r\n\t\t    {\r\n\t\t    \tx.printStackTrace();\r\n\t\t    }\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\n\r\noptions\r\nA)9 0 9\r\nB)9 7 9\r\nC)0 0 0\r\nD)0 7 0\r\n\r\nCorrect answer is : A\r\n\r\nExplanations :transient variables are not serialized when an object is serialized.\r\n\r\nIn the case of static variable you can get the values in the same JVM. \r\n\r\nQuestions no -15 \r\nWhat is the output for the below code ?\r\n\r\npublic enum Test {\r\n\tBREAKFAST(7, 30), LUNCH(12, 15), DINNER(19, 45);\r\n\t\r\n\tprivate int hh;\r\n\r\n\tprivate int mm;\r\n\r\n\tTest(int hh, int mm) {\r\n\t\tassert (hh >= 0 && hh <= 23) : ""Illegal hour."";\r\n\t\tassert (mm >= 0 && mm <= 59) : ""Illegal mins."";\r\n\t\tthis.hh = hh;\r\n\t\tthis.mm = mm;\r\n\t}\r\n\r\n\tpublic int getHour() {\r\n\t\treturn hh;\r\n\t}\r\n\r\n\tpublic int getMins() {\r\n\t\treturn mm;\r\n\t}\r\n\t\r\n\tpublic static void main(String args[]){\r\n\t\tTest t =  new BREAKFAST;\r\n\t\tSystem.out.println(t.getHour() +"":""+t.getMins());\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\noptions\r\nA)7:30\r\nB)Compile Error - an enum cannot be instantiated using the new operator.\r\nC)12:50\r\nD)19:45\r\n\r\nCorrect answer is : B\r\n\r\nExplanations : As an enum cannot be instantiated using the new operator, the constructors cannot be called explicitly.\r\nYou have to do like \r\nTest t =  BREAKFAST;\r\n\r\nQuestions no -16 \r\nWhat is the output for the below code ?\r\n\r\npublic class Test {\r\n\tenum Day {\r\n\t\tMONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY\r\n\t}\r\n\tenum Month {\r\n\t\tJAN, FEB\r\n\t}\r\n\r\n\tpublic static void main(String[] args) {\r\n\r\n\t\tint[] freqArray = { 12, 34, 56, 23, 5, 13, 78 };\r\n\r\n\t\t// Create a Map of frequencies\r\n\t\tMap<Day, Integer> ordinaryMap = new HashMap<Day, Integer>();\r\n\t\tfor (Day day : Day.values()) {\r\n\t\t\tordinaryMap.put(day, freqArray[day.ordinal()]);\r\n\t\t}\r\n\t\t\r\n\r\n\t\t// Create an EnumMap of frequencies\r\n\t\tEnumMap<Day, Integer> frequencyEnumMap = new EnumMap<Day, Integer>(ordinaryMap);\r\n\r\n\t\t// Change some frequencies\r\n\t\tfrequencyEnumMap.put(null, 100);\r\n\t\t\r\n\t\tSystem.out.println(""Frequency EnumMap: "" + frequencyEnumMap);\r\n\r\n\t\t\r\n\t}\r\n\r\n}\r\n\r\n\r\noptions\r\nA)Frequency EnumMap: {MONDAY=12, TUESDAY=34, WEDNESDAY=56, THURSDAY=23, FRIDAY=5, SATURDAY=13, SUNDAY=78}\r\nB)Compile Error \r\nC)NullPointerException\r\nD)Frequency EnumMap: {MONDAY=100, TUESDAY=34, WEDNESDAY=56, THURSDAY=23, FRIDAY=5, SATURDAY=13, SUNDAY=123}\r\n\r\nCorrect answer is : C\r\n\r\nExplanations : The null reference as a key is NOT permitted.\r\n\r\nQuestions no -17 \r\npublic class EnumTypeDeclarations {\r\n\t\r\n\tpublic void foo() {\r\n\t\t\r\n\t\tenum SimpleMeal { \r\n\t\t\tBREAKFAST, LUNCH, DINNER \r\n\t\t}\r\n\t}\r\n}\r\n\r\nIs the above code Compile without error ?\r\n\r\n\r\noptions\r\nA)Compile without error\r\nB)Compile with error\r\nC)Compile without error but Runtime Exception\r\nD)Compile without error but Enum Exception\r\n\r\nCorrect answer is : B\r\n\r\nExplanations :\r\nAn enum declaration is a special kind of class declaration:\r\n\r\na) It can be declared at the top-level and as static enum declaration. \r\n\r\nb) It is implicitly static, i.e. no outer object is associated with an enum constant. \r\n\r\nc) It is implicitly final unless it contains constant-specific class bodies, but it can implement interfaces. \r\n\r\nd) It cannot be declared abstract unless each abstract method is overridden in the constant-specific class body of every enum constant. \r\n\r\ne) Local (inner) enum declaration is NOT OK! \r\n\r\nHere in\r\npublic void foo() {\r\n\t\t\r\n\t\tenum SimpleMeal { \r\n\t\t\tBREAKFAST, LUNCH, DINNER \r\n\t\t}\r\n\t}\r\n\r\nenum declaration is local within method so compile time error.\r\n\r\nQuestions no -18 \r\nWhat is the output for the below code ?\r\n\r\npublic enum Test {\r\n\tint t;\r\n\tBREAKFAST(7, 30), LUNCH(12, 15), DINNER(19, 45);\r\n\t\r\n\tprivate int hh;\r\n\r\n\tprivate int mm;\r\n\r\n\tTest(int hh, int mm) {\r\n\t\tassert (hh >= 0 && hh <= 23) : ""Illegal hour."";\r\n\t\tassert (mm >= 0 && mm <= 59) : ""Illegal mins."";\r\n\t\tthis.hh = hh;\r\n\t\tthis.mm = mm;\r\n\t}\r\n\r\n\tpublic int getHour() {\r\n\t\treturn hh;\r\n\t}\r\n\r\n\tpublic int getMins() {\r\n\t\treturn mm;\r\n\t}\r\n\t\r\n\tpublic static void main(String args[]){\r\n\t\tTest t =  BREAKFAST;\r\n\t\tSystem.out.println(t.getHour() +"":""+t.getMins());\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\noptions\r\nA)7:30\r\nB)Compile Error \r\nC)12:15\r\nD)19:45\r\n\r\nCorrect answer is : B\r\n\r\nExplanations : The enum constants must be declared before any other declarations in an enum type.\r\n\r\nIn this case compile error because of declaration int t; before enum declaration.\r\n\r\nQuestions no -19 \r\nWhat is the output for the below code ?\r\n\r\npublic class B extends Thread{\r\npublic static void main(String argv[]){\r\nB b = new B();\r\nb.run();\r\n} \r\npublic void start(){\r\nfor (int i = 0; i < 10; i++){\r\nSystem.out.println(""Value of i = "" + i); \r\n}  \r\n}\r\n}\r\n\r\n\r\n\r\n\r\noptions\r\nA)A compile time error indicating that no run method is defined for the Thread class\r\nB)A run time error indicating that no run method is defined for the Thread class\r\nC)Clean compile and at run time the values 0 to 9 are printed out\r\nD)Clean compile but no output at runtime\r\n\r\nCorrect answer is : D\r\n\r\nExplanations : This is a bit of a sneaky one as I have swapped around the names of the methods you need to define and call when running a thread.\r\n If the for loop were defined in a method called public void run() and the call in the main method had been to b.start() The list of values from 0 to 9 \r\nwould have been output.\r\n\r\nQuestions no -20 \r\n\r\nWhat is the output for the below code ?\r\n\r\npublic class Test extends Thread{\r\n\r\n    static String sName = ""good"";\r\n    public static void main(String argv[]){\r\n    \tTest t = new Test();\r\n    t.nameTest(sName);\r\n    System.out.println(sName);\r\n    \r\n    }\r\n    public void nameTest(String sName){\r\n            sName = sName + "" idea "";\r\n             start();\r\n    }\r\n    public void run(){\r\n    \r\n    for(int i=0;i  <  4; i++){\r\n            sName = sName + "" "" + i;\r\n            \r\n    }\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n\r\noptions\r\nA)good\r\nB)good idea\r\nC)good idea good idea\r\nD)good 0 good 0 1\r\n\r\nCorrect answer is : A\r\n\r\nExplanations : Change value in local methods wouldn’t change in global in case of String ( because String object is immutable).\r\n\r\nQuestions no -21 \r\nWhat is the output for the below code ?\r\n\r\npublic class Test{\r\n\tpublic static void main(String argv[]){\r\n\tTest1 pm1 = new Test1(""One"");\r\n\tpm1.run();\r\n\tTest1 pm2 = new Test1(""Two"");\r\n\tpm2.run();\r\n\r\n\t}\r\n}\r\n\r\nclass Test1 extends Thread{\r\nprivate String sTname="""";\r\nTest1(String s){\r\n\tsTname = s;\r\n\r\n}\r\npublic void run(){\r\n\tfor(int i =0; i < 2 ; i++){\r\n\t\ttry{\r\n\t\t sleep(1000);\r\n\t\t}catch(InterruptedException e){}\r\n\r\n\t\tyield();\r\n\t\tSystem.out.println(sTname);\r\n\t\t}\r\n\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\noptions\r\nA)Compile error\r\nB)One One Two Two\r\nC)One Two One Two\r\nD)One Two\r\n\r\nCorrect answer is : B\r\n\r\nExplanations : If you call the run method directly it just acts as any other method and does not return to the calling code until it has finished. executing\r\n\r\nQuestions no -22 \r\nWhat is the output for the below code ?\r\n\r\npublic class Test extends Thread{\r\n    public static void main(String argv[]){\r\n        Test  b = new Test();\r\n        b.start();\r\n    }\r\n    public void run(){      \r\n        System.out.println(""Running"");\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\noptions\r\nA)Compilation clean and run but no output\r\nB)Compilation and run with the output ""Running""\r\nC)Compile time error with complaint of no Thread import\r\nD)Compile time error with complaint of no access to Thread package\r\n\r\nCorrect answer is : B\r\n\r\nExplanations :\r\nThe Thread class is part of the core java.lang package and does not need any explicit import statement.\r\n\r\nQuestions no -23 \r\nWhat is the output for the below code ?\r\n\r\npublic class Tech {\r\n\t public void tech() {\r\n\t      System.out.println(""Tech"");\r\n\t   }\r\n\r\n}\r\n\r\n\r\npublic class Atech {\r\n\r\n\tTech a = new Tech() {\t      \r\n\t      public void tech() {\r\n\t         System.out.println(""anonymous tech"");\r\n\t      }\r\n\t   };\r\n\t   \r\n\t   public void dothis() {\r\n\t\t      a.tech();     \r\n\t\t      \r\n\t\t   }\r\n\r\npublic static void main(String... args){\r\n\tAtech atech = new Atech();\r\n\tatech.dothis();\r\n}\r\n\r\n\r\n\r\n\r\noptions\r\nA)anonymous tech\r\nB)Compile Error \r\nC)Tech\r\nD)anonymous tech Tech\r\n\r\nCorrect answer is : A\r\n\r\nExplanations : This is anonymous subclass of the specified class type.\r\n\r\nAnonymous inner class ( anonymous subclass ) overriden the Tech super class of tech() method.\r\n\r\nTherefore Subclass method will get called.\r\n\r\nQuestions no -24 \r\nWhat is the output for the below code ?\r\n\r\npublic class Outer {\r\n\t private String x = ""Outer variable"";\r\n\t   void doStuff() {\r\n\t     String z = ""local variable"";\r\n\t     class Inner {\r\n\t       public void seeOuter() {\r\n\t         System.out.println(""Outer x is "" + x);\r\n\t         System.out.println(""Local variable z is "" + z);  \r\n\t       } \r\n\t     }   \r\n\t   }  \r\n\t   \r\n\t  \r\n}\r\n\r\n\r\n\r\n\r\noptions\r\nA)Outer x is Outer variable.\r\nB)Compile Error \r\nC)Local variable z is local variable.\r\nD)Outer x is Outer variable Local variable z is local variable\r\n\r\nCorrect answer is : B\r\n\r\nExplanations : Cannot refer to a non-final variable z inside an inner class defined in a different method.\r\n\r\nQuestions no -25\r\n\r\nWhat is the output for the below code ?\r\n\r\npublic class Test {\r\n\t\r\n\tpublic static void main(String... args) {\r\n\t\tfor(int i = 2; i < 4; i++)\r\n  for(int j = 2; j < 4; j++)\r\n     assert i!=j : i; \r\n\r\n\r\n\t}\r\n}\r\n\r\noptions\r\nA)The class compiles and runs, but does not print anything.\r\nB)The number 2 gets printed with AssertionError\r\nC)The number 3 gets printed with AssertionError\r\nD)compile error\r\n\r\nCorrect answer is : B\r\n\r\nExplanations : When i and j are both 2, assert condition is false, and AssertionError gets generated. \r\n\r\nQuestions no -26\r\n\r\nWhat is the output for the below code ?\r\n\r\npublic class Test {\r\n\t\r\n\tpublic static void main(String... args) {\r\n\t\tfor(int i = 2; i < 4; i++)\r\n  for(int j = 2; j < 4; j++)\r\n\tif(i < j)\r\n     assert i!=j : i; \r\n\r\n\r\n\t}\r\n}\r\n\r\noptions\r\nA)The class compiles and runs, but does not print anything.\r\nB)The number 2 gets printed with AssertionError\r\nC)The number 3 gets printed with AssertionError\r\nD)compile error\r\n\r\nCorrect answer is : A\r\n\r\nExplanations : When if condition returns true, the assert statement also returns true.\r\nHence AssertionError not generated.\r\n\r\nQuestions no -26 \r\nWhat is the output for the below code ?\r\n\r\npublic class NameBean {\r\n\tprivate String str;\r\n\t\r\n\tNameBean(String str ){\r\n\t\tthis.str = str;\r\n\t}\r\n\t\r\n\tpublic String toString() {\r\n\t\treturn str;\r\n\t}\r\n}\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\r\nimport java.util.HashSet;\r\n\r\npublic class CollClient {\r\n\t\r\n\tpublic static void main(String ... sss) {\r\n\t\tHashSet myMap = new HashSet();\r\n\t\tString s1 = new String(""das"");\r\n\t\tString s2 = new String(""das"");\r\n\tNameBean s3 = new NameBean(""abcdef"");\r\n\tNameBean s4 = new NameBean(""abcdef"");\r\n\t\t\r\n\t\tmyMap.add(s1);\r\n\t\tmyMap.add(s2);\r\n\t\tmyMap.add(s3);\r\n\t\tmyMap.add(s4);\r\n\t\t\r\n\t\tSystem.out.println(myMap);\r\n\t}\t\r\n}\r\n\r\n\r\n\r\n\r\noptions\r\nA)das abcdef abcdef\r\nB)das das abcdef abcdef\r\nC)das abcdef\r\nD)abcdef abcdef\r\n\r\nCorrect answer is : A\r\n\r\nExplanations : Need to implement 'equals' and 'hashCode' methods to get unique Set for user defind objects(NameBean).\r\n\r\nString object internally implements 'equals' and 'hashCode' methods therefore Set only stored one value.\r\n\r\nQuestions no -27 \r\nSynchronized resizable-array implementation of the List interface is _____________?\r\n\r\n\r\n\r\n\r\noptions\r\nA)Vector\r\nB)ArrayList\r\nC)Hashtable\r\nD)HashMap\r\n\r\nCorrect answer is : A\r\n\r\nExplanations : Vector implements List, RandomAccess - Synchronized resizable-array implementation of the List interface with additional ""legacy methods.""\r\n\r\nQuestions no -28 \r\nWhat is the output for the below code ?\r\npublic class Test {\r\n\r\n    \r\n    public static void main(String argv[]){\r\n    \t \r\n    \tArrayList list = new ArrayList(); \r\n    \tArrayList<String> listStr = list; \r\n    \tArrayList<StringBuffer> listBuf = list; \r\n    \tlistStr.add(0, ""Hello""); \r\n    \tStringBuffer buff = listBuf.get(0); \r\n       System.out.println(buff.toString());\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n\r\noptions\r\nA)Hello\r\nB)Compile error\r\nC)java.lang.ClassCastException\r\nD)null\r\n\r\nCorrect answer is : C\r\n\r\nExplanations : java.lang.String cannot be cast to java.lang.StringBuffer at the code StringBuffer buff = listBuf.get(0); \r\nSo thows java.lang.ClassCastException.\r\n\r\nQuestions no -29 \r\nWhat is the output for the below code ?\r\n\r\nimport java.util.LinkedList;\r\nimport java.util.Queue;\r\n\r\n\r\npublic class Test {\r\n\tpublic static void main(String... args) {\r\n        \r\n\t\t\r\n\t\t\r\n\t\tQueue<String> q = new LinkedList<String>();\r\n\t\t        q.add(""newyork"");\r\n\t\t        q.add(""ca"");\r\n\t\t        q.add(""texas"");\r\n\t\t        show(q);\r\n\t\t    }\r\n\t\t\r\n\t\t    public static void show(Queue q) {\r\n\t\t        q.add(new Integer(11));\r\n\t\t        while (!q.isEmpty ( ) )\r\n\t\t            System.out.print(q.poll() + ""  "");\r\n\t\t    }\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\noptions\r\nA)Compile error : Integer can't add\r\nB)newyork  ca  texas  11\r\nC)newyork  ca  texas\r\nD)newyork  ca \r\n\r\nCorrect answer is : B\r\n\r\nExplanations : \r\nq was originally declared as Queue<String>, But in show() method it is passed as an untyped Queue. nothing in the compiler or JVM prevents us from adding an Integer after that.\r\nIf the show method signature is public static void show(Queue<String> q) than you can't add Integer, Only String allowed. But public static void show(Queue q) is untyped Queue so you can add Integer.\r\npoll() Retrieves and removes the head of this queue, or returns null if this queue is empty.\r\n\r\nQuestions no -30 \r\nWhat is the output for the below code ?\r\n\r\npublic interface TestInf {\r\n int i =10;\r\n}\r\n\r\npublic class Test {\r\n\tpublic static void main(String... args) {\r\n\t\tTestInf.i=12;\r\n\t\tSystem.out.println(TestInf.i);\r\n\t\r\n\t}\r\n\t\r\n\t\r\n\t\r\n}\r\n\r\n\r\n\r\noptions\r\nA)Compile with error\r\nB)10\r\nC)12\r\nD) Runtime Exception\r\n\r\nCorrect answer is : A\r\n\r\nExplanations : All the variables declared in interface is Implicitly static and final , therefore can't change the value.\r\n\r\nQuestions no -31 \r\nWhat is the output for the below code ?\r\n\r\npublic class Test {\r\n            static { int a = 5; }\r\n            public static void main(String[] args){\r\n            System.out.println(a);\r\n            }\r\n          }\r\n\r\n\r\n\r\noptions\r\nA)Compile with error\r\nB)5\r\nC)0\r\nD) Runtime Exception\r\n\r\nCorrect answer is : A\r\n\r\nExplanations : A variable declared  in a static initialiser is not accessible outside its enclosing block.\r\n\r\nQuestions no -32 \r\nWhat is the output for the below code ?\r\n\r\nclass A {\r\n  { System.out.print(""b1 ""); }\r\n  public A() { System.out.print(""b2 ""); }\r\n}\r\nclass B extends A {\r\n  static { System.out.print(""r1 ""); }\r\n  public B() { System.out.print(""r2 ""); }\r\n  { System.out.print(""r3 ""); }\r\n  static { System.out.print(""r4 ""); }\r\n}\r\nclass C extends B {\r\n  public static void main(String[] args) {\r\n    System.out.print(""pre "");\r\n    new C();\r\n    System.out.println(""post "");\r\n  }\r\n}\r\n\r\n\r\n\r\noptions\r\nA)r1 r4 pre b1 b2 r3 r2 post\r\nB)r1 r4 pre b1 b2  post\r\nC)r1 r4 pre b1 b2  post r3 r2\r\nD)pre r1 r4  b1 b2  r2 r3 post\r\n\r\nCorrect answer is : A\r\n\r\nExplanations : All static blocks execute first then blocks and constructor. \r\n\r\nBlocks and constructor executes (super class block then super class constructor, sub class block then sub class constructor).\r\n\r\nSequence for static blocks is super class first then sub class.\r\n\r\nSequence for blocks is super class first then sub class.\r\n\r\n\r\nQuestions no -33 \r\nWhat is the output for the below code ?\r\n\r\npublic class Test {\r\n\t\r\n\tpublic static void main(String... args) throws Exception {\r\n\t\tInteger i = 34;\r\n\t\tint l = 34;\r\n\t\tif(i.equals(l)){\r\n\t\t\tSystem.out.println(true);\r\n\t\t}else{\r\n\t\t\tSystem.out.println(false);\r\n\t\t}\r\n\r\n\t}\r\n\t\r\n}\r\n\r\n\r\n\r\noptions\r\nA)true\r\nB)false\r\nC)Compile Error\r\nD) Runtime Exception\r\n\r\nCorrect answer is : A\r\n\r\nExplanations : equals() method for the integer wrappers will only return true if the two primitive types and the two values are equal.\r\n\r\nQuestions no -34 \r\nWhich statement is true about outer class?\r\n\r\n\r\n\r\noptions\r\nA)outer class can only declare public , abstract and final\r\nB)outer class may be private\r\nC)outer class can't be abstract\r\nD)outer class can be static\r\n\r\nCorrect answer is : A\r\n\r\nExplanations : outer class can only declare public , abstract and final.\r\n\r\nQuestions no -35 \r\n\r\nWhat is the output for the below code ?\r\n\r\nstatic public class Test {\r\n\tpublic static void main(String[] args) {\r\n\t\t  char c = 'a';\r\n\t\r\n\t\t switch(c){\r\n\t\t     case 65:\r\n\t\t              System.out.println(""one"");break;\r\n\t\t     case 'a':\r\n\t\t              System.out.println(""two"");break;\r\n\t\t     case 3:\r\n\t\t              System.out.println(""three"");\r\n\t\t}\r\n\t\t\r\n\t\t}\r\n\t\r\n\r\n}\r\n\r\n\r\n\r\noptions\r\nA)one\r\nB)two\r\nC)Compile error - char can't be permitted in switch statement \r\nD)Compile error - Illegal modifier for the class Test; only public, abstract & final are permitted.\r\n\r\n\r\nCorrect answer is : D\r\n\r\nExplanations : outer class can only declare public , abstract and final.\r\nIllegal modifier for the class Test; only public, abstract & final are permitted\r\n\r\nQuestions no -36\r\n\r\nWhat is the output for the below code ?\r\n\r\npublic class Test {\r\n\t\r\n\tpublic static void main(String... args) {\r\n\t\tArrayList<Integer> list = new ArrayList<Integer>();\r\n\t\tlist.add(1);\r\n\t\tlist.add(2);\r\n\t\tlist.add(3);\r\n\t\t\r\n\t\tfor(int i:list)\r\n\t\t\tSystem.out.println(i);\r\n\t\t\r\n\r\n\t}\r\n}\r\n\r\noptions\r\nA)1 2 3\r\nB)Compile error , can't add primitive type in ArrayList\r\nC)Compile error on for(int i:list) , Incorrect Syntax\r\nD)0 0 0\r\n\r\nCorrect answer is : A\r\n\r\nExplanations : JDK 1.5, 1.6 allows add primitive type in ArrayList  and for(int i:list) syntax is also correct.\r\nfor(int i:list) is same as \r\nfor(int i=0; i < list.size();i++){\r\n\t\t\tint a = list.get(i);\r\n\t\t\t\r\n\t\t}\r\n\r\nQuestions no -37 \r\nWhat is the output for the below code ?\r\n\r\npublic class SuperClass {\r\n\tpublic int doIt(String str, Integer... data)throws ArrayIndexOutOfBoundsException{\r\n\t\tString signature = ""(String, Integer[])"";\r\n\t\tSystem.out.println(str + ""  "" + signature);\r\n\t\treturn 1;\r\n\t}\r\n\r\n}\r\n\r\n\r\npublic class SubClass extends SuperClass{\r\n\r\n\tpublic int doIt(String str, Integer... data) throws Exception\r\n\t{\r\n\t\tString signature = ""(String, Integer[])"";\r\n\t\tSystem.out.println(""Overridden: "" + str + "" "" + signature);\r\n\t\treturn 0;\r\n\t}\r\n\t\r\n\tpublic static void main(String... args)\r\n\t{\r\n\t\tSuperClass sb = new SubClass();\r\n\t\ttry{\r\n\t\t\tsb.doIt(""hello"", 3);\r\n\t\t}catch(Exception e){\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t}\r\n\t\r\n}\r\n\r\n\r\n\r\noptions\r\nA)Overridden: hello (String, Integer[])\r\nB)hello (String, Integer[])\r\nC)This code throws an Exception at Runtime\r\nD)Compile with error\r\n\r\nCorrect answer is : D\r\n\r\nExplanations : Exception Exception is not compatible with throws clause in SuperClass.doIt(String, Integer[]). \r\nThe same exception or subclass of that exception is allowed.\r\n\r\nQuestions no -38\r\nWhat is the result of executing the following code, using the parameters 0 and 3 ?\r\n\r\npublic void divide(int a, int b) {\r\n\ttry {\r\n\t\tint c = a / b;\r\n\t} catch (Exception e) {\r\n\t\tSystem.out.print(""Exception "");\r\n\t} finally {\r\n\t\tSystem.out.println(""Finally"");\r\n}\r\n\r\n\r\n\r\noptions\r\nA)Prints out: Exception Finally\r\nB)Prints out: Finally\r\nC)Prints out: Exception\r\nD)Compile with error\r\n\r\nCorrect answer is : B\r\n\r\nExplanations : finally block always executed whether exception occurs or not. \r\n\t0/3 = 0 Does not throws exception.\r\n\r\nQuestions no -39\r\nWhich of the below statement is true about Error?\r\n\r\n\r\n\r\noptions\r\nA)An Error is a subclass of Throwable\r\nB)An Error is a subclass of Exception\r\nC)Error indicates serious problems that a reasonable application should not try to catch.\r\nD)An Error is a subclass of IOException\r\n\r\nCorrect answer is : A and C\r\n\r\nExplanations : An Error is a subclass of Throwable that indicates serious problems that a reasonable application should not try to catch.\r\n\r\nQuestions no -40\r\nWhich of the following is type of RuntimeException?\r\n\r\n\r\n\r\n\r\n\r\noptions\r\nA)IOException\r\nB)ArrayIndexOutOfBoundsException\r\nC)Exception\r\nD)Error\r\n\r\nCorrect answer is : B\r\n\r\nExplanations : Below is the tree.\r\njava.lang.Object\r\n  java.lang.Throwable\r\n      java.lang.Exception\r\n          java.lang.RuntimeException\r\n              java.lang.IndexOutOfBoundsException\r\n                  java.lang.ArrayIndexOutOfBoundsException\r\n\r\nQuestions no -41 \r\nWhat is the output for the below code ?\r\n\r\npublic class Test {\r\n\t\r\n\tpublic static void main(String... args) throws Exception {\r\n\t\t File file = new File(""test.txt"");  \r\n\t\t System.out.println(file.exists());\r\n\t\t FileWriter fw = new FileWriter(file); \r\n\t\t System.out.println(file.exists());\r\n\t}\r\n\t\r\n}\r\n\r\n\r\n\r\n\r\noptions\r\nA)true true\r\nB)false false\r\nC)false true\r\nD)true false\r\n\r\nCorrect answer is : C\r\n\r\nExplanations :Creating a new instance of the class File, you're not yet making an actual file, you're just creating a filename.\r\n\r\nSo file.exists() return false.\r\n\r\nFileWriter fw = new FileWriter(file) do three things:\r\n\r\nIt created a FileWriter reference variable fw.\r\n\r\nIt created a FileWriter object, and assigned it to fw.\r\n\r\nIt created an actual empty file out on the disk.\r\n\r\nSo file.exists() return true.\r\n\r\nQuestions no -42 \r\nWhen comparing java.io.BufferedWriter and java.io.FileWriter, which capability exist as a method in only one of two ?\r\n\r\n\r\n\r\n\r\noptions\r\nA)closing the stream\r\nB)flushing the stream\r\nC)writting to the stream\r\nD)writting a line separator to the stream\r\n\r\nCorrect answer is : D\r\n\r\nExplanations :A newLine() method is provided in BufferedWriter which is not in FileWriter.\r\n\r\nQuestions no -43 \r\nWhat is the output for the below code ?\r\npublic class Test{\r\n\r\npublic static void main(String[] args) {\r\n  int i1=1;\r\n switch(i1){\r\n     case 1:\r\n              System.out.println(""one"");\r\n     case 2:\r\n              System.out.println(""two"");\r\n     case 3:\r\n              System.out.println(""three"");\r\n}\r\n}\r\n}\r\n\r\n\r\noptions\r\nA)one two three\r\nB)one\r\nC)one two\r\nD)Compile error.\r\n\r\nCorrect answer is : A\r\n\r\nExplanations : There is no break statement in case 1 so it causes the below case statements to execute regardless of their values.\r\n\r\nQuestions no -44 \r\nWhat is the output for the below code ?\r\npublic class Test {\r\n\tpublic static void main(String[] args) {\r\n\t\t  char c = 'a';\r\n\t\r\n\t\t switch(c){\r\n\t\t     case 65:\r\n\t\t              System.out.println(""one"");break;\r\n\t\t     case 'a':\r\n\t\t              System.out.println(""two"");break;\r\n\t\t     case 3:\r\n\t\t              System.out.println(""three"");\r\n\t\t}\r\n\t\t\r\n\t\t}\r\n\t\r\n\r\n}\r\n\r\n\r\noptions\r\nA)one two three\r\nB)one\r\nC)two\r\nD)Compile error - char can't be in switch statement.\r\n\r\nCorrect answer is : C\r\n\r\nExplanations : Compile properly and print two.\r\n\r\nQuestions no -45 \r\nWhat is the output for the below code ?\r\n\r\nimport java.util.NavigableMap;\r\nimport java.util.concurrent.ConcurrentSkipListMap;\r\n\r\n\r\npublic class Test {\r\n\tpublic static void main(String... args) {\r\n        \r\n\t\t\r\n\t\tNavigableMap <Integer, String>navMap = new \r\n        ConcurrentSkipListMap<Integer, String>();\r\n\t\t\r\n\t\tnavMap.put(4, ""April"");\r\n\t\tnavMap.put(5, ""May"");\r\n\t\tnavMap.put(6, ""June"");\r\n\t\tnavMap.put(1, ""January"");\r\n\t\tnavMap.put(2, ""February"");\r\n\t\tnavMap.put(3, ""March"");\r\n\r\n        navMap.pollFirstEntry();\r\n        navMap.pollLastEntry();\r\n        navMap.pollFirstEntry();\r\n        System.out.println(navMap.size());\r\n\r\n\r\n\t     \t      \r\n\t}\r\n}\r\n----------------------------------- SOURCE END -------------------------------------",1419754032757
error,log,,,"Problems occurred when invoking code from plug-in: ""org.eclipse.jdt.ui"".",1419754032760
error,log,,,"Error in JDT Core during AST creation",1419754032763
error,log,,,"Exception occurred during compilation unit conversion:\r\n----------------------------------- SOURCE BEGIN -------------------------------------\r\n\r\n\t\r\nOCPJP 6 Free Mock Exam Practice Questions\r\n\r\n\r\nAre you prepared for OCPJP6 1Z0-851 exam , check your mock score ?\r\nOCPJP6 Practice Test 1Z0-851\r\n\r\nQuestions no -1 \r\nWhat is the output for the below code ?\r\n\r\nclass A implements Runnable{\r\n\tpublic void run(){\r\n\t\tSystem.out.println(Thread.currentThread().getName());\r\n\t}   \r\n}\r\n\r\n\r\npublic class Test {\t\t\r\n\tpublic static void main(String... args) {\t\r\n\t\tA a = new A();\r\n\t\tThread t = new Thread(a);\r\n\t\tThread t1 = new Thread(a);\t\t\r\n\t\tt.setName(""t"");\r\n\t\tt1.setName(""t1"");\r\n\t\tt.setPriority(10);\r\n\t\tt1.setPriority(-3);\r\n\t\tt.start();\r\n\t\tt1.start();\r\n\t\t\r\n\t}\r\n}\r\n\r\n\r\n\r\nOptions are\r\n\r\nA.t t1\r\nB.t1 t\r\nC.t t\r\nD.Compilation succeed but Runtime Exception\r\n\r\nAnswer :\r\nD is the correct answer.\r\n\r\nThread priorities are set using a positive integer, usually between 1 and 10. t1.setPriority(-3); throws java.lang.IllegalArgumentException.\r\n\r\n\r\n\r\nQuestions no -2 \r\nWhat is the output for the below code ?\r\n\r\nclass A implements Runnable{\r\n\tpublic void run(){\r\n\t\tSystem.out.println(Thread.currentThread().getName());\r\n\t}   \r\n}\r\n\r\n1. public class Test {\t\t\r\n2.\tpublic static void main(String... args) {\t\r\n3.\t\tA a = new A();\r\n4.\t\tThread t = new Thread(a);\r\n5.\t\tt.setName(""good"");\r\n6.\t\tt.start();\r\n7.\t}\r\n8. }\r\n\r\n\r\n\r\n\r\nOptions are\r\n\r\nA.good\r\nB.null\r\nC.Compilation fails with an error at line 5\r\nD.Compilation succeed but Runtime Exception\r\n\r\nAnswer :\r\nA is the correct answer.\r\n\r\nThread.currentThread().getName() return name of the current thread.\r\n\r\n\r\nQuestions no -3 \r\nWhat is the output for the below code ?\r\n\r\npublic class Test {\r\n\t\r\n\r\n\tpublic static void main(String[] args) {\r\n\t\tBoolean expr = true;\r\n\t\tif (expr) {\r\n\t\t\tSystem.out.println(""true"");\r\n\t\t} else {\r\n\t\t\tSystem.out.println(""false"");\r\n\t\t}\r\n\t\t\r\n\t}\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\noptions\r\nA)true\r\nB)Compile Error - can't use Boolean object in if().\r\nC)false\r\nD)Compile Properly but Runtime Exception.\r\n\r\nCorrect answer is : A\r\n\r\nExplanations : In the if statement, condition can be Boolean object in jdk1.5 and jdk1.6.\r\nIn the previous version only boolean is allowed.\r\n\r\nQuestions no -4 \r\nWhat is the output for the below code ?\r\n\r\npublic class Test {\r\n\t\r\n\r\n\tpublic static void main(String[] args) {\r\n\t\tList<Integer> list = new ArrayList<Integer>(); \r\n\t\tlist.add(0, 59);\r\n\t\tint total = list.get(0);\r\n\t\tSystem.out.println(total);\r\n\r\n\t\t\r\n\t}\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\noptions\r\nA)59\r\nB)Compile time error, because you have to do int total = ((Integer)(list.get(0))).intValue();\r\nC)Compile time error, because can't add primitive type in List.\r\nD)Compile Properly but Runtime Exception.\r\n\r\nCorrect answer is : A\r\n\r\nExplanations :Manual conversion between primitive types (such as an int) and wrapper classes \r\n\r\n(such as Integer) is necessary when adding a primitive data type to a collection in jdk1.4 but\r\n\r\nThe new autoboxing/unboxing feature eliminates this manual conversion in jdk 1.5 and jdk 1.6.\r\n\r\nQuestions no -3 \r\nWhat is the output for the below code ?\r\n\r\npublic class Test {\r\n\t\r\n\r\n\tpublic static void main(String[] args) {\r\n\t\tInteger i = null;\r\n\t\tint j = i;\r\n\t\tSystem.out.println(j);\r\n\t\t\r\n\t}\r\n\r\n\r\n}\r\n\r\n\r\n\r\noptions\r\nA)0\r\nB)Compile with error \r\nC)null\r\nD)NullPointerException\r\n\r\nCorrect answer is : D\r\n\r\nExplanations :An Integer expression can have a null value. If your program tries to autounbox null,\r\n it will throw a NullPointerException.\r\n\r\nQuestions no -4 \r\nWhat is the output for the below code ?\r\n\r\npublic class Outer {\r\n\tprivate int a = 7;\r\n\t   \r\n\t   class Inner {\r\n\t      public void displayValue() {\r\n\t         System.out.println(""Value of a is "" + a);\r\n\t      }\r\n\t   }\r\n\t}\r\n\r\n\r\npublic class Test {\r\n\t\r\n\tpublic static void main(String... args) throws Exception {\r\n\t\tOuter mo = new Outer();     \r\n\t\t  Outer.Inner inner = mo.new Inner();\r\n\t\t  inner.displayValue();\r\n\r\n\t}\r\n\t\r\n}\r\n\r\n\r\n\r\n\r\noptions\r\nA)Value of a is 7\r\nB)Compile Error - not able to access private member.\r\nC)Runtime Exception\r\nD)Value of a is 8\r\n\r\nCorrect answer is : A\r\n\r\nExplanations : An inner class instance can never stand alone without a direct relationship to an instance of the outer class.\r\n\r\nyou can access the inner class is through a live instance of the outer class.\r\n\r\nInner class can access private member of the outer class.\r\n\r\nQuestions no -5 \r\nWhat is the output for the below code ?\r\n\r\npublic class B {\r\n\t\r\n\tpublic String getCountryName(){\r\n\t\treturn ""USA"";\r\n\t}\r\n\t\r\n\tpublic StringBuffer getCountryName(){\r\n\t\tStringBuffer sb = new StringBuffer();\r\n\t\tsb.append(""UK"");\r\n\t\treturn sb;\r\n\t}\r\n\t\r\n\t\r\n\tpublic static void main(String[] args){\r\n\t\tB b = new B();\r\n\t\tSystem.out.println(b.getCountryName().toString());\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\noptions\r\nA)Compile with error\r\nB)USA\r\nC)UK\r\nD) Runtime Exception\r\n\r\nCorrect answer is : A\r\n\r\nExplanations : You cannot have two methods in the same class with signatures that only differ by return type.\r\n\r\nQuestions no -6\r\nWhat is the output for the below code ?\r\n\r\npublic class C {\r\n\r\n}\r\n\r\npublic class D extends C{\r\n\r\n}\r\n\r\npublic class A {\r\n\t\r\n\tpublic C getOBJ(){\r\n\t\tSystem.out.println(""class A - return C"");\r\n\t\treturn new C();\r\n\t\t\r\n\t}\r\n\r\n}\r\n\r\npublic class B extends A{\r\n\t\r\n\tpublic D getOBJ(){\r\n\t\tSystem.out.println(""class B - return D"");\r\n\t\treturn new D();\r\n\t\t\r\n\t}\r\n\r\n}\r\n\r\npublic class Test {\r\n\r\npublic static void main(String... args) {\r\n     A a = new B();\r\n     a.getOBJ();\r\n\t\r\n     }\r\n}\r\n\r\n\r\n\r\noptions\r\nA)Compile with error - Not allowed to override the return type of a method with a subtype of the original type.\r\nB)class A - return C\r\nC)class B - return D\r\nD) Runtime Exception\r\n\r\nCorrect answer is : C\r\n\r\nExplanations : From J2SE 5.0 onwards. You are now allowed to override the return type of a method with a subtype of the original type.\r\n\r\nQuestions no -7\r\nWhat is the output for the below code ?\r\n\r\npublic class A {\r\n\t\r\n\tpublic String getName() throws ArrayIndexOutOfBoundsException{\r\n\t\treturn ""Name-A"";\r\n\t}\r\n\t\r\n}\r\n\t\r\npublic class C extends A{\r\n\t\r\n\tpublic String getName() throws Exception{\r\n\t\treturn ""Name-C"";\r\n\t}\r\n\r\n}\r\n\t\r\n\t\r\npublic class Test {\r\n\tpublic static void main(String... args) {\r\n\t\tA a = new C();\r\n\t\ta.getName();\r\n\t}\r\n\t\r\n}\r\n\r\n\r\n\r\noptions\r\nA)Compile with error\r\nB)Name-A\r\nC)Name-C\r\nD)Runtime Exception\r\n\r\nCorrect answer is : A\r\n\r\nExplanations : Exception Exception is not compatible with throws clause in A.getName().\r\n\r\nOverridden method should throw only same or sub class of the exception thrown by super class method.\r\n\r\nQuestions no -8 \r\nWhat is the output for the below code ?\r\n\r\nimport java.util.regex.Matcher;\r\nimport java.util.regex.Pattern;\r\n\r\npublic class Test {\r\n\t\r\n\tpublic static void main(String... args) {\r\n            \r\n\t\tPattern p = Pattern.compile(""a*b"");\r\n\t\tMatcher m = p.matcher(""b"");\r\n\t\tboolean b = m.matches();\r\n\t\tSystem.out.println(b);\r\n\r\n\t\t\r\n\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\noptions\r\nA)true\r\nB)Compile Error\r\nC)false\r\nD)b\r\n\r\nCorrect answer is : A\r\n\r\nExplanations : a*b means ""a"" may present zero or more time and ""b"" should be present once.\r\n\r\nQuestions no -9 \r\nWhat is the output for the below code ?\r\n\r\npublic class Test {\r\n\t\r\n\tpublic static void main(String... args) {\r\n            \r\n\t\t\r\n\t\tString input = ""1 fish 2 fish red fish blue fish"";\r\n\t\tScanner s = new Scanner(input).useDelimiter(""\\\\s*fish\\\\s*"");\r\n\t\tSystem.out.println(s.nextInt());\r\n\t\tSystem.out.println(s.nextInt());\r\n\t\tSystem.out.println(s.next());\r\n\t\tSystem.out.println(s.next());\r\n\t\ts.close(); \r\n\t\t\r\n\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\noptions\r\nA)1 2 red blue\r\nB)Compile Error - because Scanner is not defind in java.\r\nC)1 fish 2 fish red fish blue fish\r\nD)1 fish 2 fish red blue fish\r\n\r\nCorrect answer is : A\r\n\r\nExplanations : java.util.Scanner is a simple text scanner which can parse primitive types and strings using regular expressions.\r\n\r\nQuestions no -10 \r\nWhat is the output for the below code ?\r\n\r\npublic class Test {\r\n\t\r\n\tpublic static void main(String... args) {\r\n            \r\n\t\tPattern p = Pattern.compile(""a{3}b?c*"");\r\n\t\tMatcher m = p.matcher(""aaab"");\r\n\t\tboolean b = m.matches();\r\n\t\tSystem.out.println(b);\r\n\r\n\t\t\r\n\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\noptions\r\nA)true\r\nB)Compile Error \r\nC)false\r\nD)NullPointerException\r\n\r\nCorrect answer is : A\r\n\r\nExplanations :\r\nX?  X, once or not at all \r\nX*  X, zero or more times \r\nX+  X, one or more times \r\nX{n}  X, exactly n times \r\nX{n,}  X, at least n times \r\nX{n,m}  X, at least n but not more than m times\r\n\r\nQuestions no -11 \r\nWhat is the output for the below code ?\r\n\r\npublic class Test {\r\n\t\r\n\tpublic static void main(String... args) {\r\n            \r\n\t\tPattern p = Pattern.compile(""a{1,3}b?c*"");\r\n\t\tMatcher m = p.matcher(""aaab"");\r\n\t\tboolean b = m.matches();\r\n\t\tSystem.out.println(b);\r\n\r\n\t\t\r\n\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\noptions\r\nA)true\r\nB)Compile Error \r\nC)false\r\nD)NullPointerException\r\n\r\nCorrect answer is : A\r\n\r\nExplanations :\r\nX?  X, once or not at all \r\nX*  X, zero or more times \r\nX+  X, one or more times \r\nX{n}  X, exactly n times \r\nX{n,}  X, at least n times \r\nX{n,m}  X, at least n but not more than m times\r\n\r\nQuestions no -12 \r\nWhat is the output for the below code ?\r\n\r\npublic class A {\r\n\tpublic A() {\r\n        System.out.println(""A"");\r\n    }\r\n}\r\n\r\npublic class B extends A implements Serializable {\r\n\tpublic B() {\r\n        System.out.println(""B"");\r\n    }\r\n\r\n}\r\n\r\npublic class Test {\r\n\t\r\n\tpublic static void main(String... args) throws Exception {\r\n\t\tB b = new B();\r\n       \r\n        ObjectOutputStream save = new ObjectOutputStream(new FileOutputStream(""datafile""));\r\n        save.writeObject(b); \r\n        save.flush(); \r\n        \r\n\r\n        ObjectInputStream restore = new ObjectInputStream(new FileInputStream(""datafile""));\r\n        B z = (B) restore.readObject();\r\n\r\n        \r\n\r\n\t}\r\n\t\r\n}\r\n\r\n\r\n\r\n\r\noptions\r\nA)A B A\r\nB)A B A B\r\nC)B B\r\nD)A B\r\n\r\nCorrect answer is : A\r\n\r\nExplanations :On the time of deserialization , the Serializable object not create new object. So constructor of class B does not called.\r\n \r\nA is not Serializable object so constructor is called.\r\n\r\nQuestions no -13 \r\nWhat is the output for the below code ?\r\n\r\npublic class A {}\r\n\r\npublic class B implements Serializable  {\r\n\tA a = new A();\r\n\tpublic static void main(String... args){\r\n\t\tB b = new B();\r\n\t\ttry{\r\n\t\t\tFileOutputStream fs = new FileOutputStream(""b.ser"");\r\n\t\t\tObjectOutputStream os = new ObjectOutputStream(fs);\r\n\t\t\tos.writeObject(b);\r\n\t\t\tos.close();\r\n\t\t\t\r\n\t\t}catch(Exception e){\r\n\t\t\te.printStackTrace();\r\n\t\t}\r\n\t\t\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\n\r\noptions\r\nA)Compilation Fail\r\nB)java.io.NotSerializableException:  Because class A is not Serializable.\r\nC)Run properly\r\nD)Compilation Fail :  Because class A is not Serializable.\r\n\r\nCorrect answer is : B\r\n\r\nExplanations :It throws java.io.NotSerializableException:A  Because class A is not Serializable.\r\n\r\nWhen JVM tries to serialize object B it will try to serialize A also because (A a = new A()) is instance variable of Class B.\r\n\r\nSo thows NotSerializableException.\r\n\r\nQuestions no -14 \r\nWhat is the output for the below code running in the same JVM?\r\n\r\npublic class A implements Serializable {\r\n\ttransient int a = 7;\r\n\t  static int b = 9;\r\n\r\n}\r\n\r\npublic class B implements Serializable  {\r\n\t\r\n\tpublic static void main(String... args){\r\n\t\tA a = new A();\r\n\t\ttry {\r\n\t\t      ObjectOutputStream os = new ObjectOutputStream(\r\n\t\t         new FileOutputStream(""test.ser""));\r\n\t\t      os.writeObject(a);  \r\n\t\t      os. close();\r\n\t\t      System.out.print( + + a.b + "" "");\r\n\r\n\t\t      ObjectInputStream is = new ObjectInputStream(new FileInputStream(""test.ser""));\r\n\t\t      A s2 = (A)is.readObject();\r\n\t\t      is.close();\r\n\t\t      System.out.println(s2.a + "" "" + s2.b);\r\n\t\t    } catch (Exception x) \r\n\t\t    {\r\n\t\t    \tx.printStackTrace();\r\n\t\t    }\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\n\r\noptions\r\nA)9 0 9\r\nB)9 7 9\r\nC)0 0 0\r\nD)0 7 0\r\n\r\nCorrect answer is : A\r\n\r\nExplanations :transient variables are not serialized when an object is serialized.\r\n\r\nIn the case of static variable you can get the values in the same JVM. \r\n\r\nQuestions no -15 \r\nWhat is the output for the below code ?\r\n\r\npublic enum Test {\r\n\tBREAKFAST(7, 30), LUNCH(12, 15), DINNER(19, 45);\r\n\t\r\n\tprivate int hh;\r\n\r\n\tprivate int mm;\r\n\r\n\tTest(int hh, int mm) {\r\n\t\tassert (hh >= 0 && hh <= 23) : ""Illegal hour."";\r\n\t\tassert (mm >= 0 && mm <= 59) : ""Illegal mins."";\r\n\t\tthis.hh = hh;\r\n\t\tthis.mm = mm;\r\n\t}\r\n\r\n\tpublic int getHour() {\r\n\t\treturn hh;\r\n\t}\r\n\r\n\tpublic int getMins() {\r\n\t\treturn mm;\r\n\t}\r\n\t\r\n\tpublic static void main(String args[]){\r\n\t\tTest t =  new BREAKFAST;\r\n\t\tSystem.out.println(t.getHour() +"":""+t.getMins());\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\noptions\r\nA)7:30\r\nB)Compile Error - an enum cannot be instantiated using the new operator.\r\nC)12:50\r\nD)19:45\r\n\r\nCorrect answer is : B\r\n\r\nExplanations : As an enum cannot be instantiated using the new operator, the constructors cannot be called explicitly.\r\nYou have to do like \r\nTest t =  BREAKFAST;\r\n\r\nQuestions no -16 \r\nWhat is the output for the below code ?\r\n\r\npublic class Test {\r\n\tenum Day {\r\n\t\tMONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY\r\n\t}\r\n\tenum Month {\r\n\t\tJAN, FEB\r\n\t}\r\n\r\n\tpublic static void main(String[] args) {\r\n\r\n\t\tint[] freqArray = { 12, 34, 56, 23, 5, 13, 78 };\r\n\r\n\t\t// Create a Map of frequencies\r\n\t\tMap<Day, Integer> ordinaryMap = new HashMap<Day, Integer>();\r\n\t\tfor (Day day : Day.values()) {\r\n\t\t\tordinaryMap.put(day, freqArray[day.ordinal()]);\r\n\t\t}\r\n\t\t\r\n\r\n\t\t// Create an EnumMap of frequencies\r\n\t\tEnumMap<Day, Integer> frequencyEnumMap = new EnumMap<Day, Integer>(ordinaryMap);\r\n\r\n\t\t// Change some frequencies\r\n\t\tfrequencyEnumMap.put(null, 100);\r\n\t\t\r\n\t\tSystem.out.println(""Frequency EnumMap: "" + frequencyEnumMap);\r\n\r\n\t\t\r\n\t}\r\n\r\n}\r\n\r\n\r\noptions\r\nA)Frequency EnumMap: {MONDAY=12, TUESDAY=34, WEDNESDAY=56, THURSDAY=23, FRIDAY=5, SATURDAY=13, SUNDAY=78}\r\nB)Compile Error \r\nC)NullPointerException\r\nD)Frequency EnumMap: {MONDAY=100, TUESDAY=34, WEDNESDAY=56, THURSDAY=23, FRIDAY=5, SATURDAY=13, SUNDAY=123}\r\n\r\nCorrect answer is : C\r\n\r\nExplanations : The null reference as a key is NOT permitted.\r\n\r\nQuestions no -17 \r\npublic class EnumTypeDeclarations {\r\n\t\r\n\tpublic void foo() {\r\n\t\t\r\n\t\tenum SimpleMeal { \r\n\t\t\tBREAKFAST, LUNCH, DINNER \r\n\t\t}\r\n\t}\r\n}\r\n\r\nIs the above code Compile without error ?\r\n\r\n\r\noptions\r\nA)Compile without error\r\nB)Compile with error\r\nC)Compile without error but Runtime Exception\r\nD)Compile without error but Enum Exception\r\n\r\nCorrect answer is : B\r\n\r\nExplanations :\r\nAn enum declaration is a special kind of class declaration:\r\n\r\na) It can be declared at the top-level and as static enum declaration. \r\n\r\nb) It is implicitly static, i.e. no outer object is associated with an enum constant. \r\n\r\nc) It is implicitly final unless it contains constant-specific class bodies, but it can implement interfaces. \r\n\r\nd) It cannot be declared abstract unless each abstract method is overridden in the constant-specific class body of every enum constant. \r\n\r\ne) Local (inner) enum declaration is NOT OK! \r\n\r\nHere in\r\npublic void foo() {\r\n\t\t\r\n\t\tenum SimpleMeal { \r\n\t\t\tBREAKFAST, LUNCH, DINNER \r\n\t\t}\r\n\t}\r\n\r\nenum declaration is local within method so compile time error.\r\n\r\nQuestions no -18 \r\nWhat is the output for the below code ?\r\n\r\npublic enum Test {\r\n\tint t;\r\n\tBREAKFAST(7, 30), LUNCH(12, 15), DINNER(19, 45);\r\n\t\r\n\tprivate int hh;\r\n\r\n\tprivate int mm;\r\n\r\n\tTest(int hh, int mm) {\r\n\t\tassert (hh >= 0 && hh <= 23) : ""Illegal hour."";\r\n\t\tassert (mm >= 0 && mm <= 59) : ""Illegal mins."";\r\n\t\tthis.hh = hh;\r\n\t\tthis.mm = mm;\r\n\t}\r\n\r\n\tpublic int getHour() {\r\n\t\treturn hh;\r\n\t}\r\n\r\n\tpublic int getMins() {\r\n\t\treturn mm;\r\n\t}\r\n\t\r\n\tpublic static void main(String args[]){\r\n\t\tTest t =  BREAKFAST;\r\n\t\tSystem.out.println(t.getHour() +"":""+t.getMins());\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\noptions\r\nA)7:30\r\nB)Compile Error \r\nC)12:15\r\nD)19:45\r\n\r\nCorrect answer is : B\r\n\r\nExplanations : The enum constants must be declared before any other declarations in an enum type.\r\n\r\nIn this case compile error because of declaration int t; before enum declaration.\r\n\r\nQuestions no -19 \r\nWhat is the output for the below code ?\r\n\r\npublic class B extends Thread{\r\npublic static void main(String argv[]){\r\nB b = new B();\r\nb.run();\r\n} \r\npublic void start(){\r\nfor (int i = 0; i < 10; i++){\r\nSystem.out.println(""Value of i = "" + i); \r\n}  \r\n}\r\n}\r\n\r\n\r\n\r\n\r\noptions\r\nA)A compile time error indicating that no run method is defined for the Thread class\r\nB)A run time error indicating that no run method is defined for the Thread class\r\nC)Clean compile and at run time the values 0 to 9 are printed out\r\nD)Clean compile but no output at runtime\r\n\r\nCorrect answer is : D\r\n\r\nExplanations : This is a bit of a sneaky one as I have swapped around the names of the methods you need to define and call when running a thread.\r\n If the for loop were defined in a method called public void run() and the call in the main method had been to b.start() The list of values from 0 to 9 \r\nwould have been output.\r\n\r\nQuestions no -20 \r\n\r\nWhat is the output for the below code ?\r\n\r\npublic class Test extends Thread{\r\n\r\n    static String sName = ""good"";\r\n    public static void main(String argv[]){\r\n    \tTest t = new Test();\r\n    t.nameTest(sName);\r\n    System.out.println(sName);\r\n    \r\n    }\r\n    public void nameTest(String sName){\r\n            sName = sName + "" idea "";\r\n             start();\r\n    }\r\n    public void run(){\r\n    \r\n    for(int i=0;i  <  4; i++){\r\n            sName = sName + "" "" + i;\r\n            \r\n    }\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n\r\noptions\r\nA)good\r\nB)good idea\r\nC)good idea good idea\r\nD)good 0 good 0 1\r\n\r\nCorrect answer is : A\r\n\r\nExplanations : Change value in local methods wouldn’t change in global in case of String ( because String object is immutable).\r\n\r\nQuestions no -21 \r\nWhat is the output for the below code ?\r\n\r\npublic class Test{\r\n\tpublic static void main(String argv[]){\r\n\tTest1 pm1 = new Test1(""One"");\r\n\tpm1.run();\r\n\tTest1 pm2 = new Test1(""Two"");\r\n\tpm2.run();\r\n\r\n\t}\r\n}\r\n\r\nclass Test1 extends Thread{\r\nprivate String sTname="""";\r\nTest1(String s){\r\n\tsTname = s;\r\n\r\n}\r\npublic void run(){\r\n\tfor(int i =0; i < 2 ; i++){\r\n\t\ttry{\r\n\t\t sleep(1000);\r\n\t\t}catch(InterruptedException e){}\r\n\r\n\t\tyield();\r\n\t\tSystem.out.println(sTname);\r\n\t\t}\r\n\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\noptions\r\nA)Compile error\r\nB)One One Two Two\r\nC)One Two One Two\r\nD)One Two\r\n\r\nCorrect answer is : B\r\n\r\nExplanations : If you call the run method directly it just acts as any other method and does not return to the calling code until it has finished. executing\r\n\r\nQuestions no -22 \r\nWhat is the output for the below code ?\r\n\r\npublic class Test extends Thread{\r\n    public static void main(String argv[]){\r\n        Test  b = new Test();\r\n        b.start();\r\n    }\r\n    public void run(){      \r\n        System.out.println(""Running"");\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\noptions\r\nA)Compilation clean and run but no output\r\nB)Compilation and run with the output ""Running""\r\nC)Compile time error with complaint of no Thread import\r\nD)Compile time error with complaint of no access to Thread package\r\n\r\nCorrect answer is : B\r\n\r\nExplanations :\r\nThe Thread class is part of the core java.lang package and does not need any explicit import statement.\r\n\r\nQuestions no -23 \r\nWhat is the output for the below code ?\r\n\r\npublic class Tech {\r\n\t public void tech() {\r\n\t      System.out.println(""Tech"");\r\n\t   }\r\n\r\n}\r\n\r\n\r\npublic class Atech {\r\n\r\n\tTech a = new Tech() {\t      \r\n\t      public void tech() {\r\n\t         System.out.println(""anonymous tech"");\r\n\t      }\r\n\t   };\r\n\t   \r\n\t   public void dothis() {\r\n\t\t      a.tech();     \r\n\t\t      \r\n\t\t   }\r\n\r\npublic static void main(String... args){\r\n\tAtech atech = new Atech();\r\n\tatech.dothis();\r\n}\r\n\r\n\r\n\r\n\r\noptions\r\nA)anonymous tech\r\nB)Compile Error \r\nC)Tech\r\nD)anonymous tech Tech\r\n\r\nCorrect answer is : A\r\n\r\nExplanations : This is anonymous subclass of the specified class type.\r\n\r\nAnonymous inner class ( anonymous subclass ) overriden the Tech super class of tech() method.\r\n\r\nTherefore Subclass method will get called.\r\n\r\nQuestions no -24 \r\nWhat is the output for the below code ?\r\n\r\npublic class Outer {\r\n\t private String x = ""Outer variable"";\r\n\t   void doStuff() {\r\n\t     String z = ""local variable"";\r\n\t     class Inner {\r\n\t       public void seeOuter() {\r\n\t         System.out.println(""Outer x is "" + x);\r\n\t         System.out.println(""Local variable z is "" + z);  \r\n\t       } \r\n\t     }   \r\n\t   }  \r\n\t   \r\n\t  \r\n}\r\n\r\n\r\n\r\n\r\noptions\r\nA)Outer x is Outer variable.\r\nB)Compile Error \r\nC)Local variable z is local variable.\r\nD)Outer x is Outer variable Local variable z is local variable\r\n\r\nCorrect answer is : B\r\n\r\nExplanations : Cannot refer to a non-final variable z inside an inner class defined in a different method.\r\n\r\nQuestions no -25\r\n\r\nWhat is the output for the below code ?\r\n\r\npublic class Test {\r\n\t\r\n\tpublic static void main(String... args) {\r\n\t\tfor(int i = 2; i < 4; i++)\r\n  for(int j = 2; j < 4; j++)\r\n     assert i!=j : i; \r\n\r\n\r\n\t}\r\n}\r\n\r\noptions\r\nA)The class compiles and runs, but does not print anything.\r\nB)The number 2 gets printed with AssertionError\r\nC)The number 3 gets printed with AssertionError\r\nD)compile error\r\n\r\nCorrect answer is : B\r\n\r\nExplanations : When i and j are both 2, assert condition is false, and AssertionError gets generated. \r\n\r\nQuestions no -26\r\n\r\nWhat is the output for the below code ?\r\n\r\npublic class Test {\r\n\t\r\n\tpublic static void main(String... args) {\r\n\t\tfor(int i = 2; i < 4; i++)\r\n  for(int j = 2; j < 4; j++)\r\n\tif(i < j)\r\n     assert i!=j : i; \r\n\r\n\r\n\t}\r\n}\r\n\r\noptions\r\nA)The class compiles and runs, but does not print anything.\r\nB)The number 2 gets printed with AssertionError\r\nC)The number 3 gets printed with AssertionError\r\nD)compile error\r\n\r\nCorrect answer is : A\r\n\r\nExplanations : When if condition returns true, the assert statement also returns true.\r\nHence AssertionError not generated.\r\n\r\nQuestions no -26 \r\nWhat is the output for the below code ?\r\n\r\npublic class NameBean {\r\n\tprivate String str;\r\n\t\r\n\tNameBean(String str ){\r\n\t\tthis.str = str;\r\n\t}\r\n\t\r\n\tpublic String toString() {\r\n\t\treturn str;\r\n\t}\r\n}\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\r\nimport java.util.HashSet;\r\n\r\npublic class CollClient {\r\n\t\r\n\tpublic static void main(String ... sss) {\r\n\t\tHashSet myMap = new HashSet();\r\n\t\tString s1 = new String(""das"");\r\n\t\tString s2 = new String(""das"");\r\n\tNameBean s3 = new NameBean(""abcdef"");\r\n\tNameBean s4 = new NameBean(""abcdef"");\r\n\t\t\r\n\t\tmyMap.add(s1);\r\n\t\tmyMap.add(s2);\r\n\t\tmyMap.add(s3);\r\n\t\tmyMap.add(s4);\r\n\t\t\r\n\t\tSystem.out.println(myMap);\r\n\t}\t\r\n}\r\n\r\n\r\n\r\n\r\noptions\r\nA)das abcdef abcdef\r\nB)das das abcdef abcdef\r\nC)das abcdef\r\nD)abcdef abcdef\r\n\r\nCorrect answer is : A\r\n\r\nExplanations : Need to implement 'equals' and 'hashCode' methods to get unique Set for user defind objects(NameBean).\r\n\r\nString object internally implements 'equals' and 'hashCode' methods therefore Set only stored one value.\r\n\r\nQuestions no -27 \r\nSynchronized resizable-array implementation of the List interface is _____________?\r\n\r\n\r\n\r\n\r\noptions\r\nA)Vector\r\nB)ArrayList\r\nC)Hashtable\r\nD)HashMap\r\n\r\nCorrect answer is : A\r\n\r\nExplanations : Vector implements List, RandomAccess - Synchronized resizable-array implementation of the List interface with additional ""legacy methods.""\r\n\r\nQuestions no -28 \r\nWhat is the output for the below code ?\r\npublic class Test {\r\n\r\n    \r\n    public static void main(String argv[]){\r\n    \t \r\n    \tArrayList list = new ArrayList(); \r\n    \tArrayList<String> listStr = list; \r\n    \tArrayList<StringBuffer> listBuf = list; \r\n    \tlistStr.add(0, ""Hello""); \r\n    \tStringBuffer buff = listBuf.get(0); \r\n       System.out.println(buff.toString());\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n\r\noptions\r\nA)Hello\r\nB)Compile error\r\nC)java.lang.ClassCastException\r\nD)null\r\n\r\nCorrect answer is : C\r\n\r\nExplanations : java.lang.String cannot be cast to java.lang.StringBuffer at the code StringBuffer buff = listBuf.get(0); \r\nSo thows java.lang.ClassCastException.\r\n\r\nQuestions no -29 \r\nWhat is the output for the below code ?\r\n\r\nimport java.util.LinkedList;\r\nimport java.util.Queue;\r\n\r\n\r\npublic class Test {\r\n\tpublic static void main(String... args) {\r\n        \r\n\t\t\r\n\t\t\r\n\t\tQueue<String> q = new LinkedList<String>();\r\n\t\t        q.add(""newyork"");\r\n\t\t        q.add(""ca"");\r\n\t\t        q.add(""texas"");\r\n\t\t        show(q);\r\n\t\t    }\r\n\t\t\r\n\t\t    public static void show(Queue q) {\r\n\t\t        q.add(new Integer(11));\r\n\t\t        while (!q.isEmpty ( ) )\r\n\t\t            System.out.print(q.poll() + ""  "");\r\n\t\t    }\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\noptions\r\nA)Compile error : Integer can't add\r\nB)newyork  ca  texas  11\r\nC)newyork  ca  texas\r\nD)newyork  ca \r\n\r\nCorrect answer is : B\r\n\r\nExplanations : \r\nq was originally declared as Queue<String>, But in show() method it is passed as an untyped Queue. nothing in the compiler or JVM prevents us from adding an Integer after that.\r\nIf the show method signature is public static void show(Queue<String> q) than you can't add Integer, Only String allowed. But public static void show(Queue q) is untyped Queue so you can add Integer.\r\npoll() Retrieves and removes the head of this queue, or returns null if this queue is empty.\r\n\r\nQuestions no -30 \r\nWhat is the output for the below code ?\r\n\r\npublic interface TestInf {\r\n int i =10;\r\n}\r\n\r\npublic class Test {\r\n\tpublic static void main(String... args) {\r\n\t\tTestInf.i=12;\r\n\t\tSystem.out.println(TestInf.i);\r\n\t\r\n\t}\r\n\t\r\n\t\r\n\t\r\n}\r\n\r\n\r\n\r\noptions\r\nA)Compile with error\r\nB)10\r\nC)12\r\nD) Runtime Exception\r\n\r\nCorrect answer is : A\r\n\r\nExplanations : All the variables declared in interface is Implicitly static and final , therefore can't change the value.\r\n\r\nQuestions no -31 \r\nWhat is the output for the below code ?\r\n\r\npublic class Test {\r\n            static { int a = 5; }\r\n            public static void main(String[] args){\r\n            System.out.println(a);\r\n            }\r\n          }\r\n\r\n\r\n\r\noptions\r\nA)Compile with error\r\nB)5\r\nC)0\r\nD) Runtime Exception\r\n\r\nCorrect answer is : A\r\n\r\nExplanations : A variable declared  in a static initialiser is not accessible outside its enclosing block.\r\n\r\nQuestions no -32 \r\nWhat is the output for the below code ?\r\n\r\nclass A {\r\n  { System.out.print(""b1 ""); }\r\n  public A() { System.out.print(""b2 ""); }\r\n}\r\nclass B extends A {\r\n  static { System.out.print(""r1 ""); }\r\n  public B() { System.out.print(""r2 ""); }\r\n  { System.out.print(""r3 ""); }\r\n  static { System.out.print(""r4 ""); }\r\n}\r\nclass C extends B {\r\n  public static void main(String[] args) {\r\n    System.out.print(""pre "");\r\n    new C();\r\n    System.out.println(""post "");\r\n  }\r\n}\r\n\r\n\r\n\r\noptions\r\nA)r1 r4 pre b1 b2 r3 r2 post\r\nB)r1 r4 pre b1 b2  post\r\nC)r1 r4 pre b1 b2  post r3 r2\r\nD)pre r1 r4  b1 b2  r2 r3 post\r\n\r\nCorrect answer is : A\r\n\r\nExplanations : All static blocks execute first then blocks and constructor. \r\n\r\nBlocks and constructor executes (super class block then super class constructor, sub class block then sub class constructor).\r\n\r\nSequence for static blocks is super class first then sub class.\r\n\r\nSequence for blocks is super class first then sub class.\r\n\r\n\r\nQuestions no -33 \r\nWhat is the output for the below code ?\r\n\r\npublic class Test {\r\n\t\r\n\tpublic static void main(String... args) throws Exception {\r\n\t\tInteger i = 34;\r\n\t\tint l = 34;\r\n\t\tif(i.equals(l)){\r\n\t\t\tSystem.out.println(true);\r\n\t\t}else{\r\n\t\t\tSystem.out.println(false);\r\n\t\t}\r\n\r\n\t}\r\n\t\r\n}\r\n\r\n\r\n\r\noptions\r\nA)true\r\nB)false\r\nC)Compile Error\r\nD) Runtime Exception\r\n\r\nCorrect answer is : A\r\n\r\nExplanations : equals() method for the integer wrappers will only return true if the two primitive types and the two values are equal.\r\n\r\nQuestions no -34 \r\nWhich statement is true about outer class?\r\n\r\n\r\n\r\noptions\r\nA)outer class can only declare public , abstract and final\r\nB)outer class may be private\r\nC)outer class can't be abstract\r\nD)outer class can be static\r\n\r\nCorrect answer is : A\r\n\r\nExplanations : outer class can only declare public , abstract and final.\r\n\r\nQuestions no -35 \r\n\r\nWhat is the output for the below code ?\r\n\r\nstatic public class Test {\r\n\tpublic static void main(String[] args) {\r\n\t\t  char c = 'a';\r\n\t\r\n\t\t switch(c){\r\n\t\t     case 65:\r\n\t\t              System.out.println(""one"");break;\r\n\t\t     case 'a':\r\n\t\t              System.out.println(""two"");break;\r\n\t\t     case 3:\r\n\t\t              System.out.println(""three"");\r\n\t\t}\r\n\t\t\r\n\t\t}\r\n\t\r\n\r\n}\r\n\r\n\r\n\r\noptions\r\nA)one\r\nB)two\r\nC)Compile error - char can't be permitted in switch statement \r\nD)Compile error - Illegal modifier for the class Test; only public, abstract & final are permitted.\r\n\r\n\r\nCorrect answer is : D\r\n\r\nExplanations : outer class can only declare public , abstract and final.\r\nIllegal modifier for the class Test; only public, abstract & final are permitted\r\n\r\nQuestions no -36\r\n\r\nWhat is the output for the below code ?\r\n\r\npublic class Test {\r\n\t\r\n\tpublic static void main(String... args) {\r\n\t\tArrayList<Integer> list = new ArrayList<Integer>();\r\n\t\tlist.add(1);\r\n\t\tlist.add(2);\r\n\t\tlist.add(3);\r\n\t\t\r\n\t\tfor(int i:list)\r\n\t\t\tSystem.out.println(i);\r\n\t\t\r\n\r\n\t}\r\n}\r\n\r\noptions\r\nA)1 2 3\r\nB)Compile error , can't add primitive type in ArrayList\r\nC)Compile error on for(int i:list) , Incorrect Syntax\r\nD)0 0 0\r\n\r\nCorrect answer is : A\r\n\r\nExplanations : JDK 1.5, 1.6 allows add primitive type in ArrayList  and for(int i:list) syntax is also correct.\r\nfor(int i:list) is same as \r\nfor(int i=0; i < list.size();i++){\r\n\t\t\tint a = list.get(i);\r\n\t\t\t\r\n\t\t}\r\n\r\nQuestions no -37 \r\nWhat is the output for the below code ?\r\n\r\npublic class SuperClass {\r\n\tpublic int doIt(String str, Integer... data)throws ArrayIndexOutOfBoundsException{\r\n\t\tString signature = ""(String, Integer[])"";\r\n\t\tSystem.out.println(str + ""  "" + signature);\r\n\t\treturn 1;\r\n\t}\r\n\r\n}\r\n\r\n\r\npublic class SubClass extends SuperClass{\r\n\r\n\tpublic int doIt(String str, Integer... data) throws Exception\r\n\t{\r\n\t\tString signature = ""(String, Integer[])"";\r\n\t\tSystem.out.println(""Overridden: "" + str + "" "" + signature);\r\n\t\treturn 0;\r\n\t}\r\n\t\r\n\tpublic static void main(String... args)\r\n\t{\r\n\t\tSuperClass sb = new SubClass();\r\n\t\ttry{\r\n\t\t\tsb.doIt(""hello"", 3);\r\n\t\t}catch(Exception e){\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t}\r\n\t\r\n}\r\n\r\n\r\n\r\noptions\r\nA)Overridden: hello (String, Integer[])\r\nB)hello (String, Integer[])\r\nC)This code throws an Exception at Runtime\r\nD)Compile with error\r\n\r\nCorrect answer is : D\r\n\r\nExplanations : Exception Exception is not compatible with throws clause in SuperClass.doIt(String, Integer[]). \r\nThe same exception or subclass of that exception is allowed.\r\n\r\nQuestions no -38\r\nWhat is the result of executing the following code, using the parameters 0 and 3 ?\r\n\r\npublic void divide(int a, int b) {\r\n\ttry {\r\n\t\tint c = a / b;\r\n\t} catch (Exception e) {\r\n\t\tSystem.out.print(""Exception "");\r\n\t} finally {\r\n\t\tSystem.out.println(""Finally"");\r\n}\r\n\r\n\r\n\r\noptions\r\nA)Prints out: Exception Finally\r\nB)Prints out: Finally\r\nC)Prints out: Exception\r\nD)Compile with error\r\n\r\nCorrect answer is : B\r\n\r\nExplanations : finally block always executed whether exception occurs or not. \r\n\t0/3 = 0 Does not throws exception.\r\n\r\nQuestions no -39\r\nWhich of the below statement is true about Error?\r\n\r\n\r\n\r\noptions\r\nA)An Error is a subclass of Throwable\r\nB)An Error is a subclass of Exception\r\nC)Error indicates serious problems that a reasonable application should not try to catch.\r\nD)An Error is a subclass of IOException\r\n\r\nCorrect answer is : A and C\r\n\r\nExplanations : An Error is a subclass of Throwable that indicates serious problems that a reasonable application should not try to catch.\r\n\r\nQuestions no -40\r\nWhich of the following is type of RuntimeException?\r\n\r\n\r\n\r\n\r\n\r\noptions\r\nA)IOException\r\nB)ArrayIndexOutOfBoundsException\r\nC)Exception\r\nD)Error\r\n\r\nCorrect answer is : B\r\n\r\nExplanations : Below is the tree.\r\njava.lang.Object\r\n  java.lang.Throwable\r\n      java.lang.Exception\r\n          java.lang.RuntimeException\r\n              java.lang.IndexOutOfBoundsException\r\n                  java.lang.ArrayIndexOutOfBoundsException\r\n\r\nQuestions no -41 \r\nWhat is the output for the below code ?\r\n\r\npublic class Test {\r\n\t\r\n\tpublic static void main(String... args) throws Exception {\r\n\t\t File file = new File(""test.txt"");  \r\n\t\t System.out.println(file.exists());\r\n\t\t FileWriter fw = new FileWriter(file); \r\n\t\t System.out.println(file.exists());\r\n\t}\r\n\t\r\n}\r\n\r\n\r\n\r\n\r\noptions\r\nA)true true\r\nB)false false\r\nC)false true\r\nD)true false\r\n\r\nCorrect answer is : C\r\n\r\nExplanations :Creating a new instance of the class File, you're not yet making an actual file, you're just creating a filename.\r\n\r\nSo file.exists() return false.\r\n\r\nFileWriter fw = new FileWriter(file) do three things:\r\n\r\nIt created a FileWriter reference variable fw.\r\n\r\nIt created a FileWriter object, and assigned it to fw.\r\n\r\nIt created an actual empty file out on the disk.\r\n\r\nSo file.exists() return true.\r\n\r\nQuestions no -42 \r\nWhen comparing java.io.BufferedWriter and java.io.FileWriter, which capability exist as a method in only one of two ?\r\n\r\n\r\n\r\n\r\noptions\r\nA)closing the stream\r\nB)flushing the stream\r\nC)writting to the stream\r\nD)writting a line separator to the stream\r\n\r\nCorrect answer is : D\r\n\r\nExplanations :A newLine() method is provided in BufferedWriter which is not in FileWriter.\r\n\r\nQuestions no -43 \r\nWhat is the output for the below code ?\r\npublic class Test{\r\n\r\npublic static void main(String[] args) {\r\n  int i1=1;\r\n switch(i1){\r\n     case 1:\r\n              System.out.println(""one"");\r\n     case 2:\r\n              System.out.println(""two"");\r\n     case 3:\r\n              System.out.println(""three"");\r\n}\r\n}\r\n}\r\n\r\n\r\noptions\r\nA)one two three\r\nB)one\r\nC)one two\r\nD)Compile error.\r\n\r\nCorrect answer is : A\r\n\r\nExplanations : There is no break statement in case 1 so it causes the below case statements to execute regardless of their values.\r\n\r\nQuestions no -44 \r\nWhat is the output for the below code ?\r\npublic class Test {\r\n\tpublic static void main(String[] args) {\r\n\t\t  char c = 'a';\r\n\t\r\n\t\t switch(c){\r\n\t\t     case 65:\r\n\t\t              System.out.println(""one"");break;\r\n\t\t     case 'a':\r\n\t\t              System.out.println(""two"");break;\r\n\t\t     case 3:\r\n\t\t              System.out.println(""three"");\r\n\t\t}\r\n\t\t\r\n\t\t}\r\n\t\r\n\r\n}\r\n\r\n\r\noptions\r\nA)one two three\r\nB)one\r\nC)two\r\nD)Compile error - char can't be in switch statement.\r\n\r\nCorrect answer is : C\r\n\r\nExplanations : Compile properly and print two.\r\n\r\nQuestions no -45 \r\nWhat is the output for the below code ?\r\n\r\nimport java.util.NavigableMap;\r\nimport java.util.concurrent.ConcurrentSkipListMap;\r\n\r\n\r\npublic class Test {\r\n\tpublic static void main(String... args) {\r\n        \r\n\t\t\r\n\t\tNavigableMap <Integer, String>navMap = new \r\n        ConcurrentSkipListMap<Integer, String>();\r\n\t\t\r\n\t\tnavMap.put(4, ""April"");\r\n\t\tnavMap.put(5, ""May"");\r\n\t\tnavMap.put(6, ""June"");\r\n\t\tnavMap.put(1, ""January"");\r\n\t\tnavMap.put(2, ""February"");\r\n\t\tnavMap.put(3, ""March"");\r\n\r\n        navMap.pollFirstEntry();\r\n        navMap.pollLastEntry();\r\n        navMap.pollFirstEntry();\r\n        System.out.println(navMap.size());\r\n\r\n\r\n\t     \t      \r\n\t}\r\n}\r\n----------------------------------- SOURCE END -------------------------------------",1419754042241
error,log,,,"Problems occurred when invoking code from plug-in: ""org.eclipse.jdt.ui"".",1419754042244
error,log,,,"Error in JDT Core during AST creation",1419754042247
no handler,command,org.eclipse.datatools.sqltools.result.ui,,"org.eclipse.datatools.sqltools.result.removeAllInstances",1419754042499
executed,command,org.eclipse.ui.ide,3.7.0.v20110809-1737,"org.eclipse.jdt.ui.edit.text.java.correction.assist.proposals",1419754048867
deactivated,workbench,org.eclipse.ui.workbench,3.7.0.I20110519-0100,"",1419754050045
